{"version":3,"sources":["webpack:///redux-cablecar.min.js","webpack:///webpack/bootstrap c98335cd613e9cc04b85","webpack:///./index.js","webpack:///./src/middleware.js","webpack:///./src/cableCar.js","webpack:///./src/cableCarDispatcher.js","webpack:///./~/actioncable/lib/assets/compiled/action_cable.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_middleware","_middleware2","middleware","_cableCar","_cableCar2","_cableCarDispatcher","_cableCarDispatcher2","cableProvider","dispatcher","CableCarDispatcher","store","next","incomingAction","action","car","type","destroyCar","CableCarChannel","getState","reset","changeCar","previousChannel","newChannel","options","channel","getCar","getDefaultCar","allows","CableCar__Action","running","send","optimistic","console","error","optimisticOnFail","connect","e","Error","CableCar","addCar","changeChannel","bind","getChannel","getParams","perform","unsubscribe","setProvider","newProvider","_classCallCheck","instance","Constructor","TypeError","_typeof","Symbol","iterator","constructor","prototype","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","_this","this","arguments","undefined","initialized","dispatch","connected","disconnected","received","msg","rejected","actionCableProvider","defaultOptions","prefix","initialize","assign","cableParams","params","subscription","createConsumer","wsURL","subscriptions","create","newAction","matchPrefix","slice","method","payload","provider","lines","addLine","line","clearAllLines","clearLine","getLines","ReferenceError","oldLine","newLine","activeLine","getSingleActiveLine","allLines","activeLines","push","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","context","ActionCable","INTERNAL","message_types","welcome","ping","confirmation","rejection","default_mount_path","protocols","WebSocket","window","logger","url","ref","getConfig","Consumer","createWebSocketURL","name","element","document","head","querySelector","getAttribute","a","test","createElement","href","protocol","replace","startDebugging","debugging","stopDebugging","log","messages","Date","now","apply","concat","fn","me","ConnectionMonitor","connection","visibilityDidChange","reconnectAttempts","clamp","secondsSince","pollInterval","min","max","staleThreshold","start","isRunning","startedAt","stoppedAt","startPolling","addEventListener","getPollInterval","stop","stopPolling","removeEventListener","recordPing","pingedAt","recordConnect","disconnectedAt","recordDisconnect","poll","clearTimeout","pollTimeout","setTimeout","reconnectIfStale","interval","Math","round","connectionIsStale","disconnectedRecently","reopen","visibilityState","isOpen","getTime","time","number","supportedProtocols","unsupportedProtocol","indexOf","item","l","Connection","consumer","open","monitor","reopenDelay","data","webSocket","JSON","stringify","isActive","uninstallEventHandlers","installEventHandlers","close","arg","allowReconnect","ref1","error1","getProtocol","isState","isProtocolSupported","states","state","readyState","toLowerCase","eventName","handler","events","message","event","identifier","parse","reload","notify","reject","notifyAll","willAttemptReconnect","Subscriptions","channelName","mixin","Subscription","add","ensureActiveConnection","sendCommand","remove","forget","findAll","len","results","s","args","callbackName","command","extend","object","properties","disconnect"],"mappings":"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","file":"redux-cablecar.min.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _middleware = __webpack_require__(1);\n\t\n\tvar _middleware2 = _interopRequireDefault(_middleware);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = _middleware2.default;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _cableCar = __webpack_require__(2);\n\t\n\tvar _cableCar2 = _interopRequireDefault(_cableCar);\n\t\n\tvar _cableCarDispatcher = __webpack_require__(3);\n\t\n\tvar _cableCarDispatcher2 = _interopRequireDefault(_cableCarDispatcher);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar cableProvider = void 0;\n\t\n\tvar dispatcher = new _cableCarDispatcher2.default();\n\t\n\tvar middleware = function middleware(store) {\n\t  return function (next) {\n\t    return function (incomingAction) {\n\t      var action = incomingAction;\n\t      var car = void 0;\n\t\n\t      switch (action.type) {\n\t\n\t        case 'CABLECAR_INITIALIZED':\n\t        case 'CABLECAR_CONNECTED':\n\t        case 'CABLECAR_DISCONNECTED':\n\t          return next(action);\n\t\n\t        case 'CABLECAR_DESTROY':\n\t          dispatcher.destroyCar(action.CableCarChannel);\n\t          return store.getState();\n\t\n\t        case 'CABLECAR_DESTROY_ALL':\n\t          dispatcher.reset();\n\t          return store.getState();\n\t\n\t        case 'CABLECAR_CHANGE_CHANNEL':\n\t          dispatcher.changeCar(action.previousChannel, action.newChannel, action.options);\n\t          return store.getState();\n\t\n\t        default:\n\t          car = action.channel ? dispatcher.getCar(action.channel) : dispatcher.getDefaultCar();\n\t          if (car && car.allows(action) && !action.CableCar__Action) {\n\t            if (car.running) {\n\t              car.send(action);\n\t            } else {\n\t              console.error('CableCar: Dropped action!', 'Attempting to dispatch an action but cable car is not running.', action, 'optimisticOnFail: ' + car.options.optimisticOnFail);\n\t              return car.options.optimisticOnFail ? next(action) : store.getState();\n\t            }\n\t            return action.optimistic ? next(action) : store.getState();\n\t          } else {\n\t            return next(action);\n\t          }\n\t      }\n\t    };\n\t  };\n\t};\n\t\n\tmiddleware.connect = function (store, channel, options) {\n\t  if (!cableProvider) {\n\t    try {\n\t      cableProvider = __webpack_require__(4);\n\t    } catch (e) {\n\t      throw new Error('CableCar: No actionCableProvider set and \\'actioncable\\' Node package failed to load: ' + e);\n\t    }\n\t  }\n\t\n\t  var car = new _cableCar2.default(cableProvider, store, channel, options);\n\t  dispatcher.addCar(channel, car);\n\t\n\t  // public car object returned\n\t  return {\n\t    changeChannel: car.changeChannel.bind(car),\n\t    getChannel: car.getChannel.bind(car),\n\t    getParams: car.getParams.bind(car),\n\t    perform: car.perform.bind(car),\n\t    send: car.send.bind(car),\n\t    unsubscribe: car.unsubscribe.bind(car)\n\t  };\n\t};\n\t\n\tmiddleware.setProvider = function (newProvider) {\n\t  cableProvider = newProvider;\n\t};\n\t\n\texports.default = middleware;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar CableCar = function () {\n\t  function CableCar(cableProvider, store, channel) {\n\t    var _this = this;\n\t\n\t    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\t\n\t    _classCallCheck(this, CableCar);\n\t\n\t    this.initialized = function () {\n\t      return _this.dispatch({ type: 'CABLECAR_INITIALIZED' });\n\t    };\n\t\n\t    this.connected = function () {\n\t      _this.dispatch({ type: 'CABLECAR_CONNECTED' });\n\t      _this.running = true;\n\t      if (_this.options.connected) {\n\t        _this.options.connected.call();\n\t      }\n\t    };\n\t\n\t    this.disconnected = function () {\n\t      _this.dispatch({ type: 'CABLECAR_DISCONNECTED' });\n\t      _this.running = false;\n\t      if (_this.options.disconnected) {\n\t        _this.options.disconnected.call();\n\t      }\n\t    };\n\t\n\t    this.received = function (msg) {\n\t      _this.dispatch(msg);\n\t    };\n\t\n\t    this.rejected = function () {\n\t      throw new Error('CableCar: Attempt to connect was rejected.\\n      (Channel: ' + _this.channel + ')');\n\t    };\n\t\n\t    if (typeof cableProvider === 'undefined') {\n\t      throw new Error('CableCar: unknown ActionCable provider: ' + cableProvider);\n\t    }\n\t\n\t    if (typeof store === 'undefined' || typeof store.dispatch === 'undefined') {\n\t      throw new Error('CableCar: unknown store: ' + store);\n\t    }\n\t\n\t    if (typeof channel !== 'string') {\n\t      throw new Error('CableCar: unknown channel: ' + channel);\n\t    }\n\t\n\t    this.actionCableProvider = cableProvider;\n\t    this.store = store;\n\t\n\t    var defaultOptions = { prefix: 'RAILS', optimisticOnFail: false };\n\t    this.initialize(channel, Object.assign(defaultOptions, options));\n\t  }\n\t\n\t  _createClass(CableCar, [{\n\t    key: 'initialize',\n\t    value: function initialize(channel, options) {\n\t\n\t      this.channel = channel;\n\t      this.options = options;\n\t      this.running = false;\n\t\n\t      var cableParams = options.params || {};\n\t      cableParams = Object.assign({ channel: channel }, cableParams);\n\t\n\t      this.subscription = this.actionCableProvider.createConsumer(options.wsURL).subscriptions.create(cableParams, {\n\t        initialized: this.initialized,\n\t        connected: this.connected,\n\t        disconnected: this.disconnected,\n\t        received: this.received,\n\t        rejected: this.rejected\n\t      });\n\t    }\n\t\n\t    // ActionCable callback functions\n\t\n\t  }, {\n\t    key: 'dispatch',\n\t\n\t\n\t    // Redux dispatch function\n\t    value: function dispatch(action) {\n\t      var newAction = Object.assign(action, {\n\t        channel: this.channel,\n\t        CableCar__Action: true\n\t      });\n\t      this.store.dispatch(newAction);\n\t    }\n\t  }, {\n\t    key: 'allows',\n\t    value: function allows(action) {\n\t      if ((typeof action === 'undefined' ? 'undefined' : _typeof(action)) !== 'object' || typeof action.type !== 'string') {\n\t        throw new Error('CableCar: ' + action + ' is not a valid redux action ({ type: ... })');\n\t      }\n\t\n\t      return this.matchPrefix(action.type);\n\t    }\n\t  }, {\n\t    key: 'matchPrefix',\n\t    value: function matchPrefix(type) {\n\t      var prefix = type.slice(0, this.options.prefix.length);\n\t      return prefix === this.options.prefix;\n\t    }\n\t\n\t    // ActionCable subscription functions (exposed globally)\n\t\n\t  }, {\n\t    key: 'changeChannel',\n\t    value: function changeChannel(channel) {\n\t      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t      this.unsubscribe();\n\t      this.initialize(channel, Object.assign(this.options, options));\n\t    }\n\t  }, {\n\t    key: 'getChannel',\n\t    value: function getChannel() {\n\t      return this.channel;\n\t    }\n\t  }, {\n\t    key: 'getParams',\n\t    value: function getParams() {\n\t      return this.options.params;\n\t    }\n\t  }, {\n\t    key: 'perform',\n\t    value: function perform(method, payload) {\n\t      this.subscription.perform(method, payload);\n\t    }\n\t  }, {\n\t    key: 'send',\n\t    value: function send(action) {\n\t      this.subscription.send(action);\n\t    }\n\t  }, {\n\t    key: 'unsubscribe',\n\t    value: function unsubscribe() {\n\t      this.subscription.unsubscribe();\n\t      this.disconnected();\n\t    }\n\t  }]);\n\t\n\t  return CableCar;\n\t}();\n\t\n\texports.default = CableCar;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar CableCarDispatcher = function () {\n\t  function CableCarDispatcher(provider) {\n\t    _classCallCheck(this, CableCarDispatcher);\n\t\n\t    var lines = {};\n\t\n\t    this.addLine = function (line, car) {\n\t      lines[line] = car;\n\t    };\n\t    this.clearAllLines = function () {\n\t      lines = {};\n\t    };\n\t    this.clearLine = function (line) {\n\t      lines[line] = undefined;\n\t    };\n\t    this.getLines = function () {\n\t      return lines;\n\t    };\n\t  }\n\t\n\t  _createClass(CableCarDispatcher, [{\n\t    key: 'addCar',\n\t    value: function addCar(line, car) {\n\t      if (this.getCar(line)) {\n\t        throw new ReferenceError('CableCar Dispatcher: cannot connect two cars to same line/channel: ' + line);\n\t      }\n\t      this.addLine(line, car);\n\t      return car;\n\t    }\n\t  }, {\n\t    key: 'changeCar',\n\t    value: function changeCar(oldLine, newLine, options) {\n\t      var car = this.getCar(oldLine);\n\t\n\t      if (!car) {\n\t        console.error(new ReferenceError('CableCar Dispatcher (change failed): no car found on line/channel: ' + oldLine));\n\t        return false;\n\t      }\n\t\n\t      if (car.changeChannel) {\n\t        car.changeChannel(newLine, options);\n\t        this.clearLine(oldLine);\n\t        this.addLine(newLine, car);\n\t        return car;\n\t      } else {\n\t        console.error(new ReferenceError('CableCar Dispatcher (change failed): car has no changeChannel function'), car);\n\t        return false;\n\t      }\n\t    }\n\t  }, {\n\t    key: 'destroyCar',\n\t    value: function destroyCar(line) {\n\t      var activeLine = line || this.getSingleActiveLine();\n\t\n\t      if (!activeLine) {\n\t        console.error(new ReferenceError('CableCar Dispatcher (destroy failed): No car found on line/channel: ' + line));\n\t        return false;\n\t      }\n\t\n\t      var car = this.getCar(activeLine);\n\t      if (car && car.unsubscribe) {\n\t        car.unsubscribe();\n\t        this.clearLine(activeLine);\n\t        return car;\n\t      } else {\n\t        console.error(new ReferenceError('CableCar Dispatcher (destroy failed): car has no unsubscribe function'), car);\n\t        return false;\n\t      }\n\t    }\n\t  }, {\n\t    key: 'getCar',\n\t    value: function getCar(line) {\n\t      return this.getLines()[line];\n\t    }\n\t  }, {\n\t    key: 'getDefaultCar',\n\t    value: function getDefaultCar() {\n\t      var activeLine = this.getSingleActiveLine();\n\t      return activeLine ? this.getLines()[activeLine] : undefined;\n\t    }\n\t  }, {\n\t    key: 'getSingleActiveLine',\n\t    value: function getSingleActiveLine() {\n\t      var allLines = this.getLines();\n\t      var activeLines = [];\n\t      for (var line in allLines) {\n\t        if (allLines[line]) {\n\t          activeLines.push(line);\n\t        }\n\t      }\n\t      return activeLines.length === 1 ? activeLines[0] : undefined;\n\t    }\n\t  }, {\n\t    key: 'reset',\n\t    value: function reset() {\n\t      this.clearAllLines();\n\t    }\n\t  }]);\n\t\n\t  return CableCarDispatcher;\n\t}();\n\t\n\texports.default = CableCarDispatcher;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function() {\n\t  var context = this;\n\t\n\t  (function() {\n\t    (function() {\n\t      var slice = [].slice;\n\t\n\t      this.ActionCable = {\n\t        INTERNAL: {\n\t          \"message_types\": {\n\t            \"welcome\": \"welcome\",\n\t            \"ping\": \"ping\",\n\t            \"confirmation\": \"confirm_subscription\",\n\t            \"rejection\": \"reject_subscription\"\n\t          },\n\t          \"default_mount_path\": \"/cable\",\n\t          \"protocols\": [\"actioncable-v1-json\", \"actioncable-unsupported\"]\n\t        },\n\t        WebSocket: window.WebSocket,\n\t        logger: window.console,\n\t        createConsumer: function(url) {\n\t          var ref;\n\t          if (url == null) {\n\t            url = (ref = this.getConfig(\"url\")) != null ? ref : this.INTERNAL.default_mount_path;\n\t          }\n\t          return new ActionCable.Consumer(this.createWebSocketURL(url));\n\t        },\n\t        getConfig: function(name) {\n\t          var element;\n\t          element = document.head.querySelector(\"meta[name='action-cable-\" + name + \"']\");\n\t          return element != null ? element.getAttribute(\"content\") : void 0;\n\t        },\n\t        createWebSocketURL: function(url) {\n\t          var a;\n\t          if (url && !/^wss?:/i.test(url)) {\n\t            a = document.createElement(\"a\");\n\t            a.href = url;\n\t            a.href = a.href;\n\t            a.protocol = a.protocol.replace(\"http\", \"ws\");\n\t            return a.href;\n\t          } else {\n\t            return url;\n\t          }\n\t        },\n\t        startDebugging: function() {\n\t          return this.debugging = true;\n\t        },\n\t        stopDebugging: function() {\n\t          return this.debugging = null;\n\t        },\n\t        log: function() {\n\t          var messages, ref;\n\t          messages = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n\t          if (this.debugging) {\n\t            messages.push(Date.now());\n\t            return (ref = this.logger).log.apply(ref, [\"[ActionCable]\"].concat(slice.call(messages)));\n\t          }\n\t        }\n\t      };\n\t\n\t    }).call(this);\n\t  }).call(context);\n\t\n\t  var ActionCable = context.ActionCable;\n\t\n\t  (function() {\n\t    (function() {\n\t      var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\t\n\t      ActionCable.ConnectionMonitor = (function() {\n\t        var clamp, now, secondsSince;\n\t\n\t        ConnectionMonitor.pollInterval = {\n\t          min: 3,\n\t          max: 30\n\t        };\n\t\n\t        ConnectionMonitor.staleThreshold = 6;\n\t\n\t        function ConnectionMonitor(connection) {\n\t          this.connection = connection;\n\t          this.visibilityDidChange = bind(this.visibilityDidChange, this);\n\t          this.reconnectAttempts = 0;\n\t        }\n\t\n\t        ConnectionMonitor.prototype.start = function() {\n\t          if (!this.isRunning()) {\n\t            this.startedAt = now();\n\t            delete this.stoppedAt;\n\t            this.startPolling();\n\t            document.addEventListener(\"visibilitychange\", this.visibilityDidChange);\n\t            return ActionCable.log(\"ConnectionMonitor started. pollInterval = \" + (this.getPollInterval()) + \" ms\");\n\t          }\n\t        };\n\t\n\t        ConnectionMonitor.prototype.stop = function() {\n\t          if (this.isRunning()) {\n\t            this.stoppedAt = now();\n\t            this.stopPolling();\n\t            document.removeEventListener(\"visibilitychange\", this.visibilityDidChange);\n\t            return ActionCable.log(\"ConnectionMonitor stopped\");\n\t          }\n\t        };\n\t\n\t        ConnectionMonitor.prototype.isRunning = function() {\n\t          return (this.startedAt != null) && (this.stoppedAt == null);\n\t        };\n\t\n\t        ConnectionMonitor.prototype.recordPing = function() {\n\t          return this.pingedAt = now();\n\t        };\n\t\n\t        ConnectionMonitor.prototype.recordConnect = function() {\n\t          this.reconnectAttempts = 0;\n\t          this.recordPing();\n\t          delete this.disconnectedAt;\n\t          return ActionCable.log(\"ConnectionMonitor recorded connect\");\n\t        };\n\t\n\t        ConnectionMonitor.prototype.recordDisconnect = function() {\n\t          this.disconnectedAt = now();\n\t          return ActionCable.log(\"ConnectionMonitor recorded disconnect\");\n\t        };\n\t\n\t        ConnectionMonitor.prototype.startPolling = function() {\n\t          this.stopPolling();\n\t          return this.poll();\n\t        };\n\t\n\t        ConnectionMonitor.prototype.stopPolling = function() {\n\t          return clearTimeout(this.pollTimeout);\n\t        };\n\t\n\t        ConnectionMonitor.prototype.poll = function() {\n\t          return this.pollTimeout = setTimeout((function(_this) {\n\t            return function() {\n\t              _this.reconnectIfStale();\n\t              return _this.poll();\n\t            };\n\t          })(this), this.getPollInterval());\n\t        };\n\t\n\t        ConnectionMonitor.prototype.getPollInterval = function() {\n\t          var interval, max, min, ref;\n\t          ref = this.constructor.pollInterval, min = ref.min, max = ref.max;\n\t          interval = 5 * Math.log(this.reconnectAttempts + 1);\n\t          return Math.round(clamp(interval, min, max) * 1000);\n\t        };\n\t\n\t        ConnectionMonitor.prototype.reconnectIfStale = function() {\n\t          if (this.connectionIsStale()) {\n\t            ActionCable.log(\"ConnectionMonitor detected stale connection. reconnectAttempts = \" + this.reconnectAttempts + \", pollInterval = \" + (this.getPollInterval()) + \" ms, time disconnected = \" + (secondsSince(this.disconnectedAt)) + \" s, stale threshold = \" + this.constructor.staleThreshold + \" s\");\n\t            this.reconnectAttempts++;\n\t            if (this.disconnectedRecently()) {\n\t              return ActionCable.log(\"ConnectionMonitor skipping reopening recent disconnect\");\n\t            } else {\n\t              ActionCable.log(\"ConnectionMonitor reopening\");\n\t              return this.connection.reopen();\n\t            }\n\t          }\n\t        };\n\t\n\t        ConnectionMonitor.prototype.connectionIsStale = function() {\n\t          var ref;\n\t          return secondsSince((ref = this.pingedAt) != null ? ref : this.startedAt) > this.constructor.staleThreshold;\n\t        };\n\t\n\t        ConnectionMonitor.prototype.disconnectedRecently = function() {\n\t          return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;\n\t        };\n\t\n\t        ConnectionMonitor.prototype.visibilityDidChange = function() {\n\t          if (document.visibilityState === \"visible\") {\n\t            return setTimeout((function(_this) {\n\t              return function() {\n\t                if (_this.connectionIsStale() || !_this.connection.isOpen()) {\n\t                  ActionCable.log(\"ConnectionMonitor reopening stale connection on visibilitychange. visbilityState = \" + document.visibilityState);\n\t                  return _this.connection.reopen();\n\t                }\n\t              };\n\t            })(this), 200);\n\t          }\n\t        };\n\t\n\t        now = function() {\n\t          return new Date().getTime();\n\t        };\n\t\n\t        secondsSince = function(time) {\n\t          return (now() - time) / 1000;\n\t        };\n\t\n\t        clamp = function(number, min, max) {\n\t          return Math.max(min, Math.min(max, number));\n\t        };\n\t\n\t        return ConnectionMonitor;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t    (function() {\n\t      var i, message_types, protocols, ref, supportedProtocols, unsupportedProtocol,\n\t        slice = [].slice,\n\t        bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n\t        indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\t\n\t      ref = ActionCable.INTERNAL, message_types = ref.message_types, protocols = ref.protocols;\n\t\n\t      supportedProtocols = 2 <= protocols.length ? slice.call(protocols, 0, i = protocols.length - 1) : (i = 0, []), unsupportedProtocol = protocols[i++];\n\t\n\t      ActionCable.Connection = (function() {\n\t        Connection.reopenDelay = 500;\n\t\n\t        function Connection(consumer) {\n\t          this.consumer = consumer;\n\t          this.open = bind(this.open, this);\n\t          this.subscriptions = this.consumer.subscriptions;\n\t          this.monitor = new ActionCable.ConnectionMonitor(this);\n\t          this.disconnected = true;\n\t        }\n\t\n\t        Connection.prototype.send = function(data) {\n\t          if (this.isOpen()) {\n\t            this.webSocket.send(JSON.stringify(data));\n\t            return true;\n\t          } else {\n\t            return false;\n\t          }\n\t        };\n\t\n\t        Connection.prototype.open = function() {\n\t          if (this.isActive()) {\n\t            ActionCable.log(\"Attempted to open WebSocket, but existing socket is \" + (this.getState()));\n\t            return false;\n\t          } else {\n\t            ActionCable.log(\"Opening WebSocket, current state is \" + (this.getState()) + \", subprotocols: \" + protocols);\n\t            if (this.webSocket != null) {\n\t              this.uninstallEventHandlers();\n\t            }\n\t            this.webSocket = new ActionCable.WebSocket(this.consumer.url, protocols);\n\t            this.installEventHandlers();\n\t            this.monitor.start();\n\t            return true;\n\t          }\n\t        };\n\t\n\t        Connection.prototype.close = function(arg) {\n\t          var allowReconnect, ref1;\n\t          allowReconnect = (arg != null ? arg : {\n\t            allowReconnect: true\n\t          }).allowReconnect;\n\t          if (!allowReconnect) {\n\t            this.monitor.stop();\n\t          }\n\t          if (this.isActive()) {\n\t            return (ref1 = this.webSocket) != null ? ref1.close() : void 0;\n\t          }\n\t        };\n\t\n\t        Connection.prototype.reopen = function() {\n\t          var error;\n\t          ActionCable.log(\"Reopening WebSocket, current state is \" + (this.getState()));\n\t          if (this.isActive()) {\n\t            try {\n\t              return this.close();\n\t            } catch (error1) {\n\t              error = error1;\n\t              return ActionCable.log(\"Failed to reopen WebSocket\", error);\n\t            } finally {\n\t              ActionCable.log(\"Reopening WebSocket in \" + this.constructor.reopenDelay + \"ms\");\n\t              setTimeout(this.open, this.constructor.reopenDelay);\n\t            }\n\t          } else {\n\t            return this.open();\n\t          }\n\t        };\n\t\n\t        Connection.prototype.getProtocol = function() {\n\t          var ref1;\n\t          return (ref1 = this.webSocket) != null ? ref1.protocol : void 0;\n\t        };\n\t\n\t        Connection.prototype.isOpen = function() {\n\t          return this.isState(\"open\");\n\t        };\n\t\n\t        Connection.prototype.isActive = function() {\n\t          return this.isState(\"open\", \"connecting\");\n\t        };\n\t\n\t        Connection.prototype.isProtocolSupported = function() {\n\t          var ref1;\n\t          return ref1 = this.getProtocol(), indexOf.call(supportedProtocols, ref1) >= 0;\n\t        };\n\t\n\t        Connection.prototype.isState = function() {\n\t          var ref1, states;\n\t          states = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n\t          return ref1 = this.getState(), indexOf.call(states, ref1) >= 0;\n\t        };\n\t\n\t        Connection.prototype.getState = function() {\n\t          var ref1, state, value;\n\t          for (state in WebSocket) {\n\t            value = WebSocket[state];\n\t            if (value === ((ref1 = this.webSocket) != null ? ref1.readyState : void 0)) {\n\t              return state.toLowerCase();\n\t            }\n\t          }\n\t          return null;\n\t        };\n\t\n\t        Connection.prototype.installEventHandlers = function() {\n\t          var eventName, handler;\n\t          for (eventName in this.events) {\n\t            handler = this.events[eventName].bind(this);\n\t            this.webSocket[\"on\" + eventName] = handler;\n\t          }\n\t        };\n\t\n\t        Connection.prototype.uninstallEventHandlers = function() {\n\t          var eventName;\n\t          for (eventName in this.events) {\n\t            this.webSocket[\"on\" + eventName] = function() {};\n\t          }\n\t        };\n\t\n\t        Connection.prototype.events = {\n\t          message: function(event) {\n\t            var identifier, message, ref1, type;\n\t            if (!this.isProtocolSupported()) {\n\t              return;\n\t            }\n\t            ref1 = JSON.parse(event.data), identifier = ref1.identifier, message = ref1.message, type = ref1.type;\n\t            switch (type) {\n\t              case message_types.welcome:\n\t                this.monitor.recordConnect();\n\t                return this.subscriptions.reload();\n\t              case message_types.ping:\n\t                return this.monitor.recordPing();\n\t              case message_types.confirmation:\n\t                return this.subscriptions.notify(identifier, \"connected\");\n\t              case message_types.rejection:\n\t                return this.subscriptions.reject(identifier);\n\t              default:\n\t                return this.subscriptions.notify(identifier, \"received\", message);\n\t            }\n\t          },\n\t          open: function() {\n\t            ActionCable.log(\"WebSocket onopen event, using '\" + (this.getProtocol()) + \"' subprotocol\");\n\t            this.disconnected = false;\n\t            if (!this.isProtocolSupported()) {\n\t              ActionCable.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n\t              return this.close({\n\t                allowReconnect: false\n\t              });\n\t            }\n\t          },\n\t          close: function(event) {\n\t            ActionCable.log(\"WebSocket onclose event\");\n\t            if (this.disconnected) {\n\t              return;\n\t            }\n\t            this.disconnected = true;\n\t            this.monitor.recordDisconnect();\n\t            return this.subscriptions.notifyAll(\"disconnected\", {\n\t              willAttemptReconnect: this.monitor.isRunning()\n\t            });\n\t          },\n\t          error: function() {\n\t            return ActionCable.log(\"WebSocket onerror event\");\n\t          }\n\t        };\n\t\n\t        return Connection;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t    (function() {\n\t      var slice = [].slice;\n\t\n\t      ActionCable.Subscriptions = (function() {\n\t        function Subscriptions(consumer) {\n\t          this.consumer = consumer;\n\t          this.subscriptions = [];\n\t        }\n\t\n\t        Subscriptions.prototype.create = function(channelName, mixin) {\n\t          var channel, params, subscription;\n\t          channel = channelName;\n\t          params = typeof channel === \"object\" ? channel : {\n\t            channel: channel\n\t          };\n\t          subscription = new ActionCable.Subscription(this.consumer, params, mixin);\n\t          return this.add(subscription);\n\t        };\n\t\n\t        Subscriptions.prototype.add = function(subscription) {\n\t          this.subscriptions.push(subscription);\n\t          this.consumer.ensureActiveConnection();\n\t          this.notify(subscription, \"initialized\");\n\t          this.sendCommand(subscription, \"subscribe\");\n\t          return subscription;\n\t        };\n\t\n\t        Subscriptions.prototype.remove = function(subscription) {\n\t          this.forget(subscription);\n\t          if (!this.findAll(subscription.identifier).length) {\n\t            this.sendCommand(subscription, \"unsubscribe\");\n\t          }\n\t          return subscription;\n\t        };\n\t\n\t        Subscriptions.prototype.reject = function(identifier) {\n\t          var i, len, ref, results, subscription;\n\t          ref = this.findAll(identifier);\n\t          results = [];\n\t          for (i = 0, len = ref.length; i < len; i++) {\n\t            subscription = ref[i];\n\t            this.forget(subscription);\n\t            this.notify(subscription, \"rejected\");\n\t            results.push(subscription);\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.forget = function(subscription) {\n\t          var s;\n\t          this.subscriptions = (function() {\n\t            var i, len, ref, results;\n\t            ref = this.subscriptions;\n\t            results = [];\n\t            for (i = 0, len = ref.length; i < len; i++) {\n\t              s = ref[i];\n\t              if (s !== subscription) {\n\t                results.push(s);\n\t              }\n\t            }\n\t            return results;\n\t          }).call(this);\n\t          return subscription;\n\t        };\n\t\n\t        Subscriptions.prototype.findAll = function(identifier) {\n\t          var i, len, ref, results, s;\n\t          ref = this.subscriptions;\n\t          results = [];\n\t          for (i = 0, len = ref.length; i < len; i++) {\n\t            s = ref[i];\n\t            if (s.identifier === identifier) {\n\t              results.push(s);\n\t            }\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.reload = function() {\n\t          var i, len, ref, results, subscription;\n\t          ref = this.subscriptions;\n\t          results = [];\n\t          for (i = 0, len = ref.length; i < len; i++) {\n\t            subscription = ref[i];\n\t            results.push(this.sendCommand(subscription, \"subscribe\"));\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.notifyAll = function() {\n\t          var args, callbackName, i, len, ref, results, subscription;\n\t          callbackName = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n\t          ref = this.subscriptions;\n\t          results = [];\n\t          for (i = 0, len = ref.length; i < len; i++) {\n\t            subscription = ref[i];\n\t            results.push(this.notify.apply(this, [subscription, callbackName].concat(slice.call(args))));\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.notify = function() {\n\t          var args, callbackName, i, len, results, subscription, subscriptions;\n\t          subscription = arguments[0], callbackName = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];\n\t          if (typeof subscription === \"string\") {\n\t            subscriptions = this.findAll(subscription);\n\t          } else {\n\t            subscriptions = [subscription];\n\t          }\n\t          results = [];\n\t          for (i = 0, len = subscriptions.length; i < len; i++) {\n\t            subscription = subscriptions[i];\n\t            results.push(typeof subscription[callbackName] === \"function\" ? subscription[callbackName].apply(subscription, args) : void 0);\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.sendCommand = function(subscription, command) {\n\t          var identifier;\n\t          identifier = subscription.identifier;\n\t          return this.consumer.send({\n\t            command: command,\n\t            identifier: identifier\n\t          });\n\t        };\n\t\n\t        return Subscriptions;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t    (function() {\n\t      ActionCable.Subscription = (function() {\n\t        var extend;\n\t\n\t        function Subscription(consumer, params, mixin) {\n\t          this.consumer = consumer;\n\t          if (params == null) {\n\t            params = {};\n\t          }\n\t          this.identifier = JSON.stringify(params);\n\t          extend(this, mixin);\n\t        }\n\t\n\t        Subscription.prototype.perform = function(action, data) {\n\t          if (data == null) {\n\t            data = {};\n\t          }\n\t          data.action = action;\n\t          return this.send(data);\n\t        };\n\t\n\t        Subscription.prototype.send = function(data) {\n\t          return this.consumer.send({\n\t            command: \"message\",\n\t            identifier: this.identifier,\n\t            data: JSON.stringify(data)\n\t          });\n\t        };\n\t\n\t        Subscription.prototype.unsubscribe = function() {\n\t          return this.consumer.subscriptions.remove(this);\n\t        };\n\t\n\t        extend = function(object, properties) {\n\t          var key, value;\n\t          if (properties != null) {\n\t            for (key in properties) {\n\t              value = properties[key];\n\t              object[key] = value;\n\t            }\n\t          }\n\t          return object;\n\t        };\n\t\n\t        return Subscription;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t    (function() {\n\t      ActionCable.Consumer = (function() {\n\t        function Consumer(url) {\n\t          this.url = url;\n\t          this.subscriptions = new ActionCable.Subscriptions(this);\n\t          this.connection = new ActionCable.Connection(this);\n\t        }\n\t\n\t        Consumer.prototype.send = function(data) {\n\t          return this.connection.send(data);\n\t        };\n\t\n\t        Consumer.prototype.connect = function() {\n\t          return this.connection.open();\n\t        };\n\t\n\t        Consumer.prototype.disconnect = function() {\n\t          return this.connection.close({\n\t            allowReconnect: false\n\t          });\n\t        };\n\t\n\t        Consumer.prototype.ensureActiveConnection = function() {\n\t          if (!this.connection.isActive()) {\n\t            return this.connection.open();\n\t          }\n\t        };\n\t\n\t        return Consumer;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t  }).call(this);\n\t\n\t  if (typeof module === \"object\" && module.exports) {\n\t    module.exports = ActionCable;\n\t  } else if (true) {\n\t    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (ActionCable), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  }\n\t}).call(this);\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// redux-cablecar.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c98335cd613e9cc04b85","import middleware from './src/middleware';\n\nexport default middleware;\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","import CableCar from './cableCar';\nimport CableCarDispatcher from './cableCarDispatcher';\n\nlet cableProvider;\n\nconst dispatcher = new CableCarDispatcher();\n\nconst middleware = store => next => (incomingAction) => {\n  const action = incomingAction;\n  let car;\n\n  switch (action.type) {\n\n    case 'CABLECAR_INITIALIZED':\n    case 'CABLECAR_CONNECTED':\n    case 'CABLECAR_DISCONNECTED':\n      return next(action);\n\n    case 'CABLECAR_DESTROY':\n      dispatcher.destroyCar(action.CableCarChannel);\n      return store.getState();\n\n    case 'CABLECAR_DESTROY_ALL':\n      dispatcher.reset();\n      return store.getState();\n\n    case 'CABLECAR_CHANGE_CHANNEL':\n      dispatcher.changeCar(action.previousChannel, action.newChannel, action.options);\n      return store.getState();\n\n    default:\n      car = action.channel ? dispatcher.getCar(action.channel) : dispatcher.getDefaultCar();\n      if (car && car.allows(action) && !action.CableCar__Action) {\n        if (car.running) {\n          car.send(action);\n        } else {\n          console.error('CableCar: Dropped action!',\n            'Attempting to dispatch an action but cable car is not running.',\n            action,\n            'optimisticOnFail: ' + car.options.optimisticOnFail\n          );\n          return car.options.optimisticOnFail ? next(action) : store.getState();\n        }\n        return action.optimistic ? next(action) : store.getState();\n      } else {\n        return next(action);\n      }\n  }\n};\n\nmiddleware.connect = (store, channel, options) => {\n  if (!cableProvider) {\n    try {\n      cableProvider = require('actioncable');\n    } catch(e) {\n      throw new Error(`CableCar: No actionCableProvider set and 'actioncable' Node package failed to load: ${e}`);\n    }\n  }\n\n  let car = new CableCar(cableProvider, store, channel, options);\n  dispatcher.addCar(channel, car);\n\n  // public car object returned\n  return {\n    changeChannel: car.changeChannel.bind(car),\n    getChannel: car.getChannel.bind(car),\n    getParams: car.getParams.bind(car),\n    perform: car.perform.bind(car),\n    send: car.send.bind(car),\n    unsubscribe: car.unsubscribe.bind(car)\n  };\n}\n\nmiddleware.setProvider = (newProvider) => {\n  cableProvider = newProvider;\n}\n\nexport default middleware;\n\n\n\n// WEBPACK FOOTER //\n// ./src/middleware.js","\nexport default class CableCar {\n\n  constructor(cableProvider, store, channel, options = {}) {\n    if (typeof cableProvider === 'undefined') {\n      throw new Error(`CableCar: unknown ActionCable provider: ${cableProvider}`);\n    }\n\n    if (typeof store === 'undefined' || typeof store.dispatch === 'undefined') {\n      throw new Error(`CableCar: unknown store: ${store}`);\n    }\n\n    if (typeof channel !== 'string') {\n      throw new Error(`CableCar: unknown channel: ${channel}`);\n    }\n\n    this.actionCableProvider = cableProvider;\n    this.store = store;\n\n    const defaultOptions = { prefix: 'RAILS', optimisticOnFail: false };\n    this.initialize(channel, Object.assign(defaultOptions, options));\n  }\n\n  initialize(channel, options) {\n\n    this.channel = channel;\n    this.options = options;\n    this.running = false;\n\n    let cableParams = options.params || {};\n    cableParams = Object.assign({ channel }, cableParams);\n\n    this.subscription = this.actionCableProvider.createConsumer(options.wsURL).subscriptions.create(\n      cableParams, {\n        initialized: this.initialized,\n        connected: this.connected,\n        disconnected: this.disconnected,\n        received: this.received,\n        rejected: this.rejected,\n      },\n    );\n  }\n\n  // ActionCable callback functions\n  initialized = () => this.dispatch({ type: 'CABLECAR_INITIALIZED' });\n\n  connected = () => {\n    this.dispatch({ type: 'CABLECAR_CONNECTED' });\n    this.running = true;\n    if (this.options.connected) { this.options.connected.call(); }\n  }\n\n  disconnected = () => {\n    this.dispatch({ type: 'CABLECAR_DISCONNECTED' });\n    this.running = false;\n    if (this.options.disconnected) { this.options.disconnected.call(); }\n  }\n\n  received = (msg) => {\n    this.dispatch(msg);\n  }\n\n  rejected = () => {\n    throw new Error(\n      `CableCar: Attempt to connect was rejected.\n      (Channel: ${this.channel})`,\n    );\n  }\n\n  // Redux dispatch function\n  dispatch(action) {\n    const newAction = Object.assign(action, {\n      channel: this.channel,\n      CableCar__Action: true,\n    });\n    this.store.dispatch(newAction);\n  }\n\n  allows(action) {\n    if (typeof action !== 'object' || typeof action.type !== 'string') {\n      throw new Error(`CableCar: ${action} is not a valid redux action ({ type: ... })`);\n    }\n\n    return this.matchPrefix(action.type);\n  }\n\n  matchPrefix(type) {\n    const prefix = type.slice(0, this.options.prefix.length);\n    return prefix === this.options.prefix;\n  }\n\n  // ActionCable subscription functions (exposed globally)\n  changeChannel(channel, options = {}) {\n    this.unsubscribe();\n    this.initialize(channel, Object.assign(this.options, options));\n  }\n\n  getChannel() {\n    return this.channel;\n  }\n\n  getParams() {\n    return this.options.params;\n  }\n\n  perform(method, payload) {\n    this.subscription.perform(method, payload);\n  }\n\n  send(action) {\n    this.subscription.send(action);\n  }\n\n  unsubscribe() {\n    this.subscription.unsubscribe();\n    this.disconnected();\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/cableCar.js","\nexport default class CableCarDispatcher {\n\n  constructor(provider) {\n    let lines = {};\n\n    this.addLine = (line, car) => { lines[line] = car; }\n    this.clearAllLines = () => { lines = {}; }\n    this.clearLine = (line) => { lines[line] = undefined; }\n    this.getLines = () => lines;\n  }\n\n  addCar(line, car) {\n    if (this.getCar(line)) {\n      throw(new ReferenceError(\n        'CableCar Dispatcher: cannot connect two cars to same line/channel: ' + line\n      ));\n    }\n    this.addLine(line, car);\n    return car;\n  }\n\n  changeCar(oldLine, newLine, options) {\n    let car = this.getCar(oldLine);\n\n    if (!car) {\n      console.error(new ReferenceError(\n        'CableCar Dispatcher (change failed): no car found on line/channel: ' + oldLine\n      ));\n      return false;\n    }\n\n    if (car.changeChannel) {\n      car.changeChannel(newLine, options);\n      this.clearLine(oldLine);\n      this.addLine(newLine, car);\n      return car;\n    } else {\n      console.error(new ReferenceError(\n        'CableCar Dispatcher (change failed): car has no changeChannel function'\n      ), car);\n      return false;\n    }\n  }\n\n  destroyCar(line) {\n    let activeLine = line || this.getSingleActiveLine();\n\n    if (!activeLine) {\n      console.error(new ReferenceError(\n        'CableCar Dispatcher (destroy failed): No car found on line/channel: ' + line\n      ))\n      return false;\n    }\n\n    let car = this.getCar(activeLine);\n    if (car && car.unsubscribe) {\n      car.unsubscribe();\n      this.clearLine(activeLine);\n      return car;\n    } else {\n      console.error(new ReferenceError(\n        'CableCar Dispatcher (destroy failed): car has no unsubscribe function'\n      ), car);\n      return false;\n    }\n  }\n\n  getCar(line) {\n    return this.getLines()[line];\n  }\n\n  getDefaultCar() {\n    let activeLine = this.getSingleActiveLine();\n    return activeLine ? this.getLines()[activeLine] : undefined;\n  }\n\n  getSingleActiveLine() {\n    const allLines = this.getLines();\n    let activeLines = [];\n    for (let line in allLines) {\n      if (allLines[line]) { activeLines.push(line); }\n    }\n    return activeLines.length === 1 ? activeLines[0] : undefined;\n  }\n\n  reset() {\n    this.clearAllLines();\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/cableCarDispatcher.js","(function() {\n  var context = this;\n\n  (function() {\n    (function() {\n      var slice = [].slice;\n\n      this.ActionCable = {\n        INTERNAL: {\n          \"message_types\": {\n            \"welcome\": \"welcome\",\n            \"ping\": \"ping\",\n            \"confirmation\": \"confirm_subscription\",\n            \"rejection\": \"reject_subscription\"\n          },\n          \"default_mount_path\": \"/cable\",\n          \"protocols\": [\"actioncable-v1-json\", \"actioncable-unsupported\"]\n        },\n        WebSocket: window.WebSocket,\n        logger: window.console,\n        createConsumer: function(url) {\n          var ref;\n          if (url == null) {\n            url = (ref = this.getConfig(\"url\")) != null ? ref : this.INTERNAL.default_mount_path;\n          }\n          return new ActionCable.Consumer(this.createWebSocketURL(url));\n        },\n        getConfig: function(name) {\n          var element;\n          element = document.head.querySelector(\"meta[name='action-cable-\" + name + \"']\");\n          return element != null ? element.getAttribute(\"content\") : void 0;\n        },\n        createWebSocketURL: function(url) {\n          var a;\n          if (url && !/^wss?:/i.test(url)) {\n            a = document.createElement(\"a\");\n            a.href = url;\n            a.href = a.href;\n            a.protocol = a.protocol.replace(\"http\", \"ws\");\n            return a.href;\n          } else {\n            return url;\n          }\n        },\n        startDebugging: function() {\n          return this.debugging = true;\n        },\n        stopDebugging: function() {\n          return this.debugging = null;\n        },\n        log: function() {\n          var messages, ref;\n          messages = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          if (this.debugging) {\n            messages.push(Date.now());\n            return (ref = this.logger).log.apply(ref, [\"[ActionCable]\"].concat(slice.call(messages)));\n          }\n        }\n      };\n\n    }).call(this);\n  }).call(context);\n\n  var ActionCable = context.ActionCable;\n\n  (function() {\n    (function() {\n      var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n      ActionCable.ConnectionMonitor = (function() {\n        var clamp, now, secondsSince;\n\n        ConnectionMonitor.pollInterval = {\n          min: 3,\n          max: 30\n        };\n\n        ConnectionMonitor.staleThreshold = 6;\n\n        function ConnectionMonitor(connection) {\n          this.connection = connection;\n          this.visibilityDidChange = bind(this.visibilityDidChange, this);\n          this.reconnectAttempts = 0;\n        }\n\n        ConnectionMonitor.prototype.start = function() {\n          if (!this.isRunning()) {\n            this.startedAt = now();\n            delete this.stoppedAt;\n            this.startPolling();\n            document.addEventListener(\"visibilitychange\", this.visibilityDidChange);\n            return ActionCable.log(\"ConnectionMonitor started. pollInterval = \" + (this.getPollInterval()) + \" ms\");\n          }\n        };\n\n        ConnectionMonitor.prototype.stop = function() {\n          if (this.isRunning()) {\n            this.stoppedAt = now();\n            this.stopPolling();\n            document.removeEventListener(\"visibilitychange\", this.visibilityDidChange);\n            return ActionCable.log(\"ConnectionMonitor stopped\");\n          }\n        };\n\n        ConnectionMonitor.prototype.isRunning = function() {\n          return (this.startedAt != null) && (this.stoppedAt == null);\n        };\n\n        ConnectionMonitor.prototype.recordPing = function() {\n          return this.pingedAt = now();\n        };\n\n        ConnectionMonitor.prototype.recordConnect = function() {\n          this.reconnectAttempts = 0;\n          this.recordPing();\n          delete this.disconnectedAt;\n          return ActionCable.log(\"ConnectionMonitor recorded connect\");\n        };\n\n        ConnectionMonitor.prototype.recordDisconnect = function() {\n          this.disconnectedAt = now();\n          return ActionCable.log(\"ConnectionMonitor recorded disconnect\");\n        };\n\n        ConnectionMonitor.prototype.startPolling = function() {\n          this.stopPolling();\n          return this.poll();\n        };\n\n        ConnectionMonitor.prototype.stopPolling = function() {\n          return clearTimeout(this.pollTimeout);\n        };\n\n        ConnectionMonitor.prototype.poll = function() {\n          return this.pollTimeout = setTimeout((function(_this) {\n            return function() {\n              _this.reconnectIfStale();\n              return _this.poll();\n            };\n          })(this), this.getPollInterval());\n        };\n\n        ConnectionMonitor.prototype.getPollInterval = function() {\n          var interval, max, min, ref;\n          ref = this.constructor.pollInterval, min = ref.min, max = ref.max;\n          interval = 5 * Math.log(this.reconnectAttempts + 1);\n          return Math.round(clamp(interval, min, max) * 1000);\n        };\n\n        ConnectionMonitor.prototype.reconnectIfStale = function() {\n          if (this.connectionIsStale()) {\n            ActionCable.log(\"ConnectionMonitor detected stale connection. reconnectAttempts = \" + this.reconnectAttempts + \", pollInterval = \" + (this.getPollInterval()) + \" ms, time disconnected = \" + (secondsSince(this.disconnectedAt)) + \" s, stale threshold = \" + this.constructor.staleThreshold + \" s\");\n            this.reconnectAttempts++;\n            if (this.disconnectedRecently()) {\n              return ActionCable.log(\"ConnectionMonitor skipping reopening recent disconnect\");\n            } else {\n              ActionCable.log(\"ConnectionMonitor reopening\");\n              return this.connection.reopen();\n            }\n          }\n        };\n\n        ConnectionMonitor.prototype.connectionIsStale = function() {\n          var ref;\n          return secondsSince((ref = this.pingedAt) != null ? ref : this.startedAt) > this.constructor.staleThreshold;\n        };\n\n        ConnectionMonitor.prototype.disconnectedRecently = function() {\n          return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;\n        };\n\n        ConnectionMonitor.prototype.visibilityDidChange = function() {\n          if (document.visibilityState === \"visible\") {\n            return setTimeout((function(_this) {\n              return function() {\n                if (_this.connectionIsStale() || !_this.connection.isOpen()) {\n                  ActionCable.log(\"ConnectionMonitor reopening stale connection on visibilitychange. visbilityState = \" + document.visibilityState);\n                  return _this.connection.reopen();\n                }\n              };\n            })(this), 200);\n          }\n        };\n\n        now = function() {\n          return new Date().getTime();\n        };\n\n        secondsSince = function(time) {\n          return (now() - time) / 1000;\n        };\n\n        clamp = function(number, min, max) {\n          return Math.max(min, Math.min(max, number));\n        };\n\n        return ConnectionMonitor;\n\n      })();\n\n    }).call(this);\n    (function() {\n      var i, message_types, protocols, ref, supportedProtocols, unsupportedProtocol,\n        slice = [].slice,\n        bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n        indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n      ref = ActionCable.INTERNAL, message_types = ref.message_types, protocols = ref.protocols;\n\n      supportedProtocols = 2 <= protocols.length ? slice.call(protocols, 0, i = protocols.length - 1) : (i = 0, []), unsupportedProtocol = protocols[i++];\n\n      ActionCable.Connection = (function() {\n        Connection.reopenDelay = 500;\n\n        function Connection(consumer) {\n          this.consumer = consumer;\n          this.open = bind(this.open, this);\n          this.subscriptions = this.consumer.subscriptions;\n          this.monitor = new ActionCable.ConnectionMonitor(this);\n          this.disconnected = true;\n        }\n\n        Connection.prototype.send = function(data) {\n          if (this.isOpen()) {\n            this.webSocket.send(JSON.stringify(data));\n            return true;\n          } else {\n            return false;\n          }\n        };\n\n        Connection.prototype.open = function() {\n          if (this.isActive()) {\n            ActionCable.log(\"Attempted to open WebSocket, but existing socket is \" + (this.getState()));\n            return false;\n          } else {\n            ActionCable.log(\"Opening WebSocket, current state is \" + (this.getState()) + \", subprotocols: \" + protocols);\n            if (this.webSocket != null) {\n              this.uninstallEventHandlers();\n            }\n            this.webSocket = new ActionCable.WebSocket(this.consumer.url, protocols);\n            this.installEventHandlers();\n            this.monitor.start();\n            return true;\n          }\n        };\n\n        Connection.prototype.close = function(arg) {\n          var allowReconnect, ref1;\n          allowReconnect = (arg != null ? arg : {\n            allowReconnect: true\n          }).allowReconnect;\n          if (!allowReconnect) {\n            this.monitor.stop();\n          }\n          if (this.isActive()) {\n            return (ref1 = this.webSocket) != null ? ref1.close() : void 0;\n          }\n        };\n\n        Connection.prototype.reopen = function() {\n          var error;\n          ActionCable.log(\"Reopening WebSocket, current state is \" + (this.getState()));\n          if (this.isActive()) {\n            try {\n              return this.close();\n            } catch (error1) {\n              error = error1;\n              return ActionCable.log(\"Failed to reopen WebSocket\", error);\n            } finally {\n              ActionCable.log(\"Reopening WebSocket in \" + this.constructor.reopenDelay + \"ms\");\n              setTimeout(this.open, this.constructor.reopenDelay);\n            }\n          } else {\n            return this.open();\n          }\n        };\n\n        Connection.prototype.getProtocol = function() {\n          var ref1;\n          return (ref1 = this.webSocket) != null ? ref1.protocol : void 0;\n        };\n\n        Connection.prototype.isOpen = function() {\n          return this.isState(\"open\");\n        };\n\n        Connection.prototype.isActive = function() {\n          return this.isState(\"open\", \"connecting\");\n        };\n\n        Connection.prototype.isProtocolSupported = function() {\n          var ref1;\n          return ref1 = this.getProtocol(), indexOf.call(supportedProtocols, ref1) >= 0;\n        };\n\n        Connection.prototype.isState = function() {\n          var ref1, states;\n          states = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          return ref1 = this.getState(), indexOf.call(states, ref1) >= 0;\n        };\n\n        Connection.prototype.getState = function() {\n          var ref1, state, value;\n          for (state in WebSocket) {\n            value = WebSocket[state];\n            if (value === ((ref1 = this.webSocket) != null ? ref1.readyState : void 0)) {\n              return state.toLowerCase();\n            }\n          }\n          return null;\n        };\n\n        Connection.prototype.installEventHandlers = function() {\n          var eventName, handler;\n          for (eventName in this.events) {\n            handler = this.events[eventName].bind(this);\n            this.webSocket[\"on\" + eventName] = handler;\n          }\n        };\n\n        Connection.prototype.uninstallEventHandlers = function() {\n          var eventName;\n          for (eventName in this.events) {\n            this.webSocket[\"on\" + eventName] = function() {};\n          }\n        };\n\n        Connection.prototype.events = {\n          message: function(event) {\n            var identifier, message, ref1, type;\n            if (!this.isProtocolSupported()) {\n              return;\n            }\n            ref1 = JSON.parse(event.data), identifier = ref1.identifier, message = ref1.message, type = ref1.type;\n            switch (type) {\n              case message_types.welcome:\n                this.monitor.recordConnect();\n                return this.subscriptions.reload();\n              case message_types.ping:\n                return this.monitor.recordPing();\n              case message_types.confirmation:\n                return this.subscriptions.notify(identifier, \"connected\");\n              case message_types.rejection:\n                return this.subscriptions.reject(identifier);\n              default:\n                return this.subscriptions.notify(identifier, \"received\", message);\n            }\n          },\n          open: function() {\n            ActionCable.log(\"WebSocket onopen event, using '\" + (this.getProtocol()) + \"' subprotocol\");\n            this.disconnected = false;\n            if (!this.isProtocolSupported()) {\n              ActionCable.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n              return this.close({\n                allowReconnect: false\n              });\n            }\n          },\n          close: function(event) {\n            ActionCable.log(\"WebSocket onclose event\");\n            if (this.disconnected) {\n              return;\n            }\n            this.disconnected = true;\n            this.monitor.recordDisconnect();\n            return this.subscriptions.notifyAll(\"disconnected\", {\n              willAttemptReconnect: this.monitor.isRunning()\n            });\n          },\n          error: function() {\n            return ActionCable.log(\"WebSocket onerror event\");\n          }\n        };\n\n        return Connection;\n\n      })();\n\n    }).call(this);\n    (function() {\n      var slice = [].slice;\n\n      ActionCable.Subscriptions = (function() {\n        function Subscriptions(consumer) {\n          this.consumer = consumer;\n          this.subscriptions = [];\n        }\n\n        Subscriptions.prototype.create = function(channelName, mixin) {\n          var channel, params, subscription;\n          channel = channelName;\n          params = typeof channel === \"object\" ? channel : {\n            channel: channel\n          };\n          subscription = new ActionCable.Subscription(this.consumer, params, mixin);\n          return this.add(subscription);\n        };\n\n        Subscriptions.prototype.add = function(subscription) {\n          this.subscriptions.push(subscription);\n          this.consumer.ensureActiveConnection();\n          this.notify(subscription, \"initialized\");\n          this.sendCommand(subscription, \"subscribe\");\n          return subscription;\n        };\n\n        Subscriptions.prototype.remove = function(subscription) {\n          this.forget(subscription);\n          if (!this.findAll(subscription.identifier).length) {\n            this.sendCommand(subscription, \"unsubscribe\");\n          }\n          return subscription;\n        };\n\n        Subscriptions.prototype.reject = function(identifier) {\n          var i, len, ref, results, subscription;\n          ref = this.findAll(identifier);\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            subscription = ref[i];\n            this.forget(subscription);\n            this.notify(subscription, \"rejected\");\n            results.push(subscription);\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.forget = function(subscription) {\n          var s;\n          this.subscriptions = (function() {\n            var i, len, ref, results;\n            ref = this.subscriptions;\n            results = [];\n            for (i = 0, len = ref.length; i < len; i++) {\n              s = ref[i];\n              if (s !== subscription) {\n                results.push(s);\n              }\n            }\n            return results;\n          }).call(this);\n          return subscription;\n        };\n\n        Subscriptions.prototype.findAll = function(identifier) {\n          var i, len, ref, results, s;\n          ref = this.subscriptions;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            s = ref[i];\n            if (s.identifier === identifier) {\n              results.push(s);\n            }\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.reload = function() {\n          var i, len, ref, results, subscription;\n          ref = this.subscriptions;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            subscription = ref[i];\n            results.push(this.sendCommand(subscription, \"subscribe\"));\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.notifyAll = function() {\n          var args, callbackName, i, len, ref, results, subscription;\n          callbackName = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n          ref = this.subscriptions;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            subscription = ref[i];\n            results.push(this.notify.apply(this, [subscription, callbackName].concat(slice.call(args))));\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.notify = function() {\n          var args, callbackName, i, len, results, subscription, subscriptions;\n          subscription = arguments[0], callbackName = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];\n          if (typeof subscription === \"string\") {\n            subscriptions = this.findAll(subscription);\n          } else {\n            subscriptions = [subscription];\n          }\n          results = [];\n          for (i = 0, len = subscriptions.length; i < len; i++) {\n            subscription = subscriptions[i];\n            results.push(typeof subscription[callbackName] === \"function\" ? subscription[callbackName].apply(subscription, args) : void 0);\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.sendCommand = function(subscription, command) {\n          var identifier;\n          identifier = subscription.identifier;\n          return this.consumer.send({\n            command: command,\n            identifier: identifier\n          });\n        };\n\n        return Subscriptions;\n\n      })();\n\n    }).call(this);\n    (function() {\n      ActionCable.Subscription = (function() {\n        var extend;\n\n        function Subscription(consumer, params, mixin) {\n          this.consumer = consumer;\n          if (params == null) {\n            params = {};\n          }\n          this.identifier = JSON.stringify(params);\n          extend(this, mixin);\n        }\n\n        Subscription.prototype.perform = function(action, data) {\n          if (data == null) {\n            data = {};\n          }\n          data.action = action;\n          return this.send(data);\n        };\n\n        Subscription.prototype.send = function(data) {\n          return this.consumer.send({\n            command: \"message\",\n            identifier: this.identifier,\n            data: JSON.stringify(data)\n          });\n        };\n\n        Subscription.prototype.unsubscribe = function() {\n          return this.consumer.subscriptions.remove(this);\n        };\n\n        extend = function(object, properties) {\n          var key, value;\n          if (properties != null) {\n            for (key in properties) {\n              value = properties[key];\n              object[key] = value;\n            }\n          }\n          return object;\n        };\n\n        return Subscription;\n\n      })();\n\n    }).call(this);\n    (function() {\n      ActionCable.Consumer = (function() {\n        function Consumer(url) {\n          this.url = url;\n          this.subscriptions = new ActionCable.Subscriptions(this);\n          this.connection = new ActionCable.Connection(this);\n        }\n\n        Consumer.prototype.send = function(data) {\n          return this.connection.send(data);\n        };\n\n        Consumer.prototype.connect = function() {\n          return this.connection.open();\n        };\n\n        Consumer.prototype.disconnect = function() {\n          return this.connection.close({\n            allowReconnect: false\n          });\n        };\n\n        Consumer.prototype.ensureActiveConnection = function() {\n          if (!this.connection.isActive()) {\n            return this.connection.open();\n          }\n        };\n\n        return Consumer;\n\n      })();\n\n    }).call(this);\n  }).call(this);\n\n  if (typeof module === \"object\" && module.exports) {\n    module.exports = ActionCable;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(ActionCable);\n  }\n}).call(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/actioncable/lib/assets/compiled/action_cable.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}