{"version":3,"sources":["webpack:///redux-cablecar.min.js","webpack:///webpack/bootstrap c98335cd613e9cc04b85","webpack:///./index.js","webpack:///./src/middleware.js","webpack:///./src/cableCar.js","webpack:///./src/cableCarDispatcher.js","webpack:///./~/actioncable/lib/assets/compiled/action_cable.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_middleware","_middleware2","_cableCar","_cableCar2","_cableCarDispatcher","_cableCarDispatcher2","cableProvider","dispatcher","middleware","store","next","incomingAction","action","car","type","destroyCar","CableCarChannel","getState","reset","changeCar","previousChannel","newChannel","options","channel","getCar","getDefaultCar","allows","CableCar__Action","running","send","optimistic","console","error","optimisticOnFail","connect","e","Error","addCar","changeChannel","bind","getChannel","getParams","perform","unsubscribe","setProvider","newProvider","_classCallCheck","instance","Constructor","TypeError","_typeof","Symbol","iterator","constructor","prototype","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","CableCar","_this","this","arguments","undefined","initialized","dispatch","connected","disconnected","received","msg","rejected","actionCableProvider","defaultOptions","prefix","initialize","assign","cableParams","params","subscription","createConsumer","wsURL","subscriptions","create","newAction","matchPrefix","slice","method","payload","CableCarDispatcher","provider","lines","addLine","line","clearAllLines","clearLine","getLines","ReferenceError","oldLine","newLine","activeLine","getSingleActiveLine","allLines","activeLines","push","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","context","ActionCable","INTERNAL","message_types","welcome","ping","confirmation","rejection","default_mount_path","protocols","WebSocket","window","logger","url","ref","getConfig","Consumer","createWebSocketURL","name","element","document","head","querySelector","getAttribute","a","test","createElement","href","protocol","replace","startDebugging","debugging","stopDebugging","log","messages","Date","now","apply","concat","fn","me","ConnectionMonitor","connection","visibilityDidChange","reconnectAttempts","clamp","secondsSince","pollInterval","min","max","staleThreshold","start","isRunning","startedAt","stoppedAt","startPolling","addEventListener","getPollInterval","stop","stopPolling","removeEventListener","recordPing","pingedAt","recordConnect","disconnectedAt","recordDisconnect","poll","clearTimeout","pollTimeout","setTimeout","reconnectIfStale","interval","Math","round","connectionIsStale","disconnectedRecently","reopen","visibilityState","isOpen","getTime","time","number","supportedProtocols","unsupportedProtocol","indexOf","item","l","Connection","consumer","open","monitor","reopenDelay","data","webSocket","JSON","stringify","isActive","uninstallEventHandlers","installEventHandlers","close","arg","allowReconnect","ref1","error1","getProtocol","isState","isProtocolSupported","states","state","readyState","toLowerCase","eventName","handler","events","message","event","identifier","parse","reload","notify","reject","notifyAll","willAttemptReconnect","Subscriptions","channelName","mixin","Subscription","add","ensureActiveConnection","sendCommand","remove","forget","findAll","len","results","s","args","callbackName","command","extend","object","properties","disconnect"],"mappings":"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","file":"redux-cablecar.min.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _middleware = __webpack_require__(1);\n\t\n\tvar _middleware2 = _interopRequireDefault(_middleware);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\texports.default = _middleware2.default;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _cableCar = __webpack_require__(2);\n\t\n\tvar _cableCar2 = _interopRequireDefault(_cableCar);\n\t\n\tvar _cableCarDispatcher = __webpack_require__(3);\n\t\n\tvar _cableCarDispatcher2 = _interopRequireDefault(_cableCarDispatcher);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar cableProvider = void 0;\n\t\n\tvar dispatcher = new _cableCarDispatcher2.default();\n\t\n\tvar middleware = function middleware(store) {\n\t  return function (next) {\n\t    return function (incomingAction) {\n\t      var action = incomingAction;\n\t      var car = void 0;\n\t\n\t      switch (action.type) {\n\t\n\t        case 'CABLECAR_INITIALIZED':\n\t        case 'CABLECAR_CONNECTED':\n\t        case 'CABLECAR_DISCONNECTED':\n\t          return next(action);\n\t\n\t        case 'CABLECAR_DESTROY':\n\t          dispatcher.destroyCar(action.CableCarChannel);\n\t          return store.getState();\n\t\n\t        case 'CABLECAR_DESTROY_ALL':\n\t          dispatcher.reset();\n\t          return store.getState();\n\t\n\t        case 'CABLECAR_CHANGE_CHANNEL':\n\t          dispatcher.changeCar(action.previousChannel, action.newChannel, action.options);\n\t          return store.getState();\n\t\n\t        default:\n\t          car = action.channel ? dispatcher.getCar(action.channel) : dispatcher.getDefaultCar();\n\t          if (car && car.allows(action) && !action.CableCar__Action) {\n\t            if (car.running) {\n\t              car.send(action);\n\t            } else {\n\t              console.error('CableCar: Dropped action!', 'Attempting to dispatch an action but cable car is not running.', action, 'optimisticOnFail: ' + car.options.optimisticOnFail);\n\t              return car.options.optimisticOnFail ? next(action) : store.getState();\n\t            }\n\t            return action.optimistic ? next(action) : store.getState();\n\t          } else {\n\t            return next(action);\n\t          }\n\t      }\n\t    };\n\t  };\n\t};\n\t\n\tmiddleware.connect = function (store, channel, options) {\n\t  if (!cableProvider) {\n\t    try {\n\t      cableProvider = __webpack_require__(4);\n\t    } catch (e) {\n\t      throw new Error('CableCar: No actionCableProvider set and \\'actioncable\\' Node package failed to load: ' + e);\n\t    }\n\t  }\n\t\n\t  var car = new _cableCar2.default(cableProvider, store, channel, options);\n\t  dispatcher.addCar(channel, car);\n\t\n\t  // public car object returned\n\t  return {\n\t    changeChannel: car.changeChannel.bind(car),\n\t    getChannel: car.getChannel.bind(car),\n\t    getParams: car.getParams.bind(car),\n\t    perform: car.perform.bind(car),\n\t    send: car.send.bind(car),\n\t    unsubscribe: car.unsubscribe.bind(car)\n\t  };\n\t};\n\t\n\tmiddleware.setProvider = function (newProvider) {\n\t  cableProvider = newProvider;\n\t};\n\t\n\texports.default = middleware;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar CableCar = function () {\n\t  function CableCar(cableProvider, store, channel) {\n\t    var _this = this;\n\t\n\t    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\t\n\t    _classCallCheck(this, CableCar);\n\t\n\t    this.initialized = function () {\n\t      return _this.dispatch({ type: 'CABLECAR_INITIALIZED' });\n\t    };\n\t\n\t    this.connected = function () {\n\t      _this.dispatch({ type: 'CABLECAR_CONNECTED' });\n\t      _this.running = true;\n\t      if (_this.options.connected) {\n\t        _this.options.connected.call();\n\t      }\n\t    };\n\t\n\t    this.disconnected = function () {\n\t      _this.dispatch({ type: 'CABLECAR_DISCONNECTED' });\n\t      _this.running = false;\n\t      if (_this.options.disconnected) {\n\t        _this.options.disconnected.call();\n\t      }\n\t    };\n\t\n\t    this.received = function (msg) {\n\t      _this.dispatch(msg);\n\t    };\n\t\n\t    this.rejected = function () {\n\t      throw new Error('CableCar: Attempt to connect was rejected.\\n      (Channel: ' + _this.channel + ')');\n\t    };\n\t\n\t    if (typeof cableProvider === 'undefined') {\n\t      throw new Error('CableCar: unknown ActionCable provider: ' + cableProvider);\n\t    }\n\t\n\t    if (typeof store === 'undefined' || typeof store.dispatch === 'undefined') {\n\t      throw new Error('CableCar: unknown store: ' + store);\n\t    }\n\t\n\t    if (typeof channel !== 'string') {\n\t      throw new Error('CableCar: unknown channel: ' + channel);\n\t    }\n\t\n\t    this.actionCableProvider = cableProvider;\n\t    this.store = store;\n\t\n\t    var defaultOptions = { prefix: 'RAILS', optimisticOnFail: false };\n\t    this.initialize(channel, Object.assign(defaultOptions, options));\n\t  }\n\t\n\t  _createClass(CableCar, [{\n\t    key: 'initialize',\n\t    value: function initialize(channel, options) {\n\t\n\t      this.channel = channel;\n\t      this.options = options;\n\t      this.running = false;\n\t\n\t      var cableParams = options.params || {};\n\t      cableParams = Object.assign({ channel: channel }, cableParams);\n\t\n\t      this.subscription = this.actionCableProvider.createConsumer(options.wsURL).subscriptions.create(cableParams, {\n\t        initialized: this.initialized,\n\t        connected: this.connected,\n\t        disconnected: this.disconnected,\n\t        received: this.received,\n\t        rejected: this.rejected\n\t      });\n\t    }\n\t\n\t    // ActionCable callback functions\n\t\n\t  }, {\n\t    key: 'dispatch',\n\t\n\t\n\t    // Redux dispatch function\n\t    value: function dispatch(action) {\n\t      var newAction = Object.assign(action, {\n\t        channel: this.channel,\n\t        CableCar__Action: true\n\t      });\n\t      this.store.dispatch(newAction);\n\t    }\n\t  }, {\n\t    key: 'allows',\n\t    value: function allows(action) {\n\t      if ((typeof action === 'undefined' ? 'undefined' : _typeof(action)) !== 'object' || typeof action.type !== 'string') {\n\t        throw new Error('CableCar: ' + action + ' is not a valid redux action ({ type: ... })');\n\t      }\n\t\n\t      return this.matchPrefix(action.type);\n\t    }\n\t  }, {\n\t    key: 'matchPrefix',\n\t    value: function matchPrefix(type) {\n\t      var prefix = type.slice(0, this.options.prefix.length);\n\t      return prefix === this.options.prefix;\n\t    }\n\t\n\t    // ActionCable subscription functions (exposed globally)\n\t\n\t  }, {\n\t    key: 'changeChannel',\n\t    value: function changeChannel(channel) {\n\t      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t      this.unsubscribe();\n\t      this.initialize(channel, Object.assign(this.options, options));\n\t    }\n\t  }, {\n\t    key: 'getChannel',\n\t    value: function getChannel() {\n\t      return this.channel;\n\t    }\n\t  }, {\n\t    key: 'getParams',\n\t    value: function getParams() {\n\t      return this.options.params;\n\t    }\n\t  }, {\n\t    key: 'perform',\n\t    value: function perform(method, payload) {\n\t      this.subscription.perform(method, payload);\n\t    }\n\t  }, {\n\t    key: 'send',\n\t    value: function send(action) {\n\t      this.subscription.send(action);\n\t    }\n\t  }, {\n\t    key: 'unsubscribe',\n\t    value: function unsubscribe() {\n\t      this.subscription.unsubscribe();\n\t      this.disconnected();\n\t    }\n\t  }]);\n\t\n\t  return CableCar;\n\t}();\n\t\n\texports.default = CableCar;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar CableCarDispatcher = function () {\n\t  function CableCarDispatcher(provider) {\n\t    _classCallCheck(this, CableCarDispatcher);\n\t\n\t    var lines = {};\n\t\n\t    this.addLine = function (line, car) {\n\t      lines[line] = car;\n\t    };\n\t    this.clearAllLines = function () {\n\t      lines = {};\n\t    };\n\t    this.clearLine = function (line) {\n\t      lines[line] = undefined;\n\t    };\n\t    this.getLines = function () {\n\t      return lines;\n\t    };\n\t  }\n\t\n\t  _createClass(CableCarDispatcher, [{\n\t    key: 'addCar',\n\t    value: function addCar(line, car) {\n\t      if (this.getCar(line)) {\n\t        throw new ReferenceError('CableCar Dispatcher: cannot connect two cars to same line/channel: ' + line);\n\t      }\n\t      this.addLine(line, car);\n\t      return car;\n\t    }\n\t  }, {\n\t    key: 'changeCar',\n\t    value: function changeCar(oldLine, newLine, options) {\n\t      var car = this.getCar(oldLine);\n\t\n\t      if (!car) {\n\t        console.error(new ReferenceError('CableCar Dispatcher (change failed): no car found on line/channel: ' + oldLine));\n\t        return false;\n\t      }\n\t\n\t      if (car.changeChannel) {\n\t        car.changeChannel(newLine, options);\n\t        this.clearLine(oldLine);\n\t        this.addLine(newLine, car);\n\t        return car;\n\t      } else {\n\t        console.error(new ReferenceError('CableCar Dispatcher (change failed): car has no changeChannel function'), car);\n\t        return false;\n\t      }\n\t    }\n\t  }, {\n\t    key: 'destroyCar',\n\t    value: function destroyCar(line) {\n\t      var activeLine = line || this.getSingleActiveLine();\n\t\n\t      if (!activeLine) {\n\t        console.error(new ReferenceError('CableCar Dispatcher (destroy failed): No car found on line/channel: ' + line));\n\t        return false;\n\t      }\n\t\n\t      var car = this.getCar(activeLine);\n\t      if (car && car.unsubscribe) {\n\t        car.unsubscribe();\n\t        this.clearLine(activeLine);\n\t        return car;\n\t      } else {\n\t        console.error(new ReferenceError('CableCar Dispatcher (destroy failed): car has no unsubscribe function'), car);\n\t        return false;\n\t      }\n\t    }\n\t  }, {\n\t    key: 'getCar',\n\t    value: function getCar(line) {\n\t      return this.getLines()[line];\n\t    }\n\t  }, {\n\t    key: 'getDefaultCar',\n\t    value: function getDefaultCar() {\n\t      var activeLine = this.getSingleActiveLine();\n\t      return activeLine ? this.getLines()[activeLine] : undefined;\n\t    }\n\t  }, {\n\t    key: 'getSingleActiveLine',\n\t    value: function getSingleActiveLine() {\n\t      var allLines = this.getLines();\n\t      var activeLines = [];\n\t      for (var line in allLines) {\n\t        if (allLines[line]) {\n\t          activeLines.push(line);\n\t        }\n\t      }\n\t      return activeLines.length === 1 ? activeLines[0] : undefined;\n\t    }\n\t  }, {\n\t    key: 'reset',\n\t    value: function reset() {\n\t      this.clearAllLines();\n\t    }\n\t  }]);\n\t\n\t  return CableCarDispatcher;\n\t}();\n\t\n\texports.default = CableCarDispatcher;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function() {\n\t  var context = this;\n\t\n\t  (function() {\n\t    (function() {\n\t      var slice = [].slice;\n\t\n\t      this.ActionCable = {\n\t        INTERNAL: {\n\t          \"message_types\": {\n\t            \"welcome\": \"welcome\",\n\t            \"ping\": \"ping\",\n\t            \"confirmation\": \"confirm_subscription\",\n\t            \"rejection\": \"reject_subscription\"\n\t          },\n\t          \"default_mount_path\": \"/cable\",\n\t          \"protocols\": [\"actioncable-v1-json\", \"actioncable-unsupported\"]\n\t        },\n\t        WebSocket: window.WebSocket,\n\t        logger: window.console,\n\t        createConsumer: function(url) {\n\t          var ref;\n\t          if (url == null) {\n\t            url = (ref = this.getConfig(\"url\")) != null ? ref : this.INTERNAL.default_mount_path;\n\t          }\n\t          return new ActionCable.Consumer(this.createWebSocketURL(url));\n\t        },\n\t        getConfig: function(name) {\n\t          var element;\n\t          element = document.head.querySelector(\"meta[name='action-cable-\" + name + \"']\");\n\t          return element != null ? element.getAttribute(\"content\") : void 0;\n\t        },\n\t        createWebSocketURL: function(url) {\n\t          var a;\n\t          if (url && !/^wss?:/i.test(url)) {\n\t            a = document.createElement(\"a\");\n\t            a.href = url;\n\t            a.href = a.href;\n\t            a.protocol = a.protocol.replace(\"http\", \"ws\");\n\t            return a.href;\n\t          } else {\n\t            return url;\n\t          }\n\t        },\n\t        startDebugging: function() {\n\t          return this.debugging = true;\n\t        },\n\t        stopDebugging: function() {\n\t          return this.debugging = null;\n\t        },\n\t        log: function() {\n\t          var messages, ref;\n\t          messages = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n\t          if (this.debugging) {\n\t            messages.push(Date.now());\n\t            return (ref = this.logger).log.apply(ref, [\"[ActionCable]\"].concat(slice.call(messages)));\n\t          }\n\t        }\n\t      };\n\t\n\t    }).call(this);\n\t  }).call(context);\n\t\n\t  var ActionCable = context.ActionCable;\n\t\n\t  (function() {\n\t    (function() {\n\t      var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\t\n\t      ActionCable.ConnectionMonitor = (function() {\n\t        var clamp, now, secondsSince;\n\t\n\t        ConnectionMonitor.pollInterval = {\n\t          min: 3,\n\t          max: 30\n\t        };\n\t\n\t        ConnectionMonitor.staleThreshold = 6;\n\t\n\t        function ConnectionMonitor(connection) {\n\t          this.connection = connection;\n\t          this.visibilityDidChange = bind(this.visibilityDidChange, this);\n\t          this.reconnectAttempts = 0;\n\t        }\n\t\n\t        ConnectionMonitor.prototype.start = function() {\n\t          if (!this.isRunning()) {\n\t            this.startedAt = now();\n\t            delete this.stoppedAt;\n\t            this.startPolling();\n\t            document.addEventListener(\"visibilitychange\", this.visibilityDidChange);\n\t            return ActionCable.log(\"ConnectionMonitor started. pollInterval = \" + (this.getPollInterval()) + \" ms\");\n\t          }\n\t        };\n\t\n\t        ConnectionMonitor.prototype.stop = function() {\n\t          if (this.isRunning()) {\n\t            this.stoppedAt = now();\n\t            this.stopPolling();\n\t            document.removeEventListener(\"visibilitychange\", this.visibilityDidChange);\n\t            return ActionCable.log(\"ConnectionMonitor stopped\");\n\t          }\n\t        };\n\t\n\t        ConnectionMonitor.prototype.isRunning = function() {\n\t          return (this.startedAt != null) && (this.stoppedAt == null);\n\t        };\n\t\n\t        ConnectionMonitor.prototype.recordPing = function() {\n\t          return this.pingedAt = now();\n\t        };\n\t\n\t        ConnectionMonitor.prototype.recordConnect = function() {\n\t          this.reconnectAttempts = 0;\n\t          this.recordPing();\n\t          delete this.disconnectedAt;\n\t          return ActionCable.log(\"ConnectionMonitor recorded connect\");\n\t        };\n\t\n\t        ConnectionMonitor.prototype.recordDisconnect = function() {\n\t          this.disconnectedAt = now();\n\t          return ActionCable.log(\"ConnectionMonitor recorded disconnect\");\n\t        };\n\t\n\t        ConnectionMonitor.prototype.startPolling = function() {\n\t          this.stopPolling();\n\t          return this.poll();\n\t        };\n\t\n\t        ConnectionMonitor.prototype.stopPolling = function() {\n\t          return clearTimeout(this.pollTimeout);\n\t        };\n\t\n\t        ConnectionMonitor.prototype.poll = function() {\n\t          return this.pollTimeout = setTimeout((function(_this) {\n\t            return function() {\n\t              _this.reconnectIfStale();\n\t              return _this.poll();\n\t            };\n\t          })(this), this.getPollInterval());\n\t        };\n\t\n\t        ConnectionMonitor.prototype.getPollInterval = function() {\n\t          var interval, max, min, ref;\n\t          ref = this.constructor.pollInterval, min = ref.min, max = ref.max;\n\t          interval = 5 * Math.log(this.reconnectAttempts + 1);\n\t          return Math.round(clamp(interval, min, max) * 1000);\n\t        };\n\t\n\t        ConnectionMonitor.prototype.reconnectIfStale = function() {\n\t          if (this.connectionIsStale()) {\n\t            ActionCable.log(\"ConnectionMonitor detected stale connection. reconnectAttempts = \" + this.reconnectAttempts + \", pollInterval = \" + (this.getPollInterval()) + \" ms, time disconnected = \" + (secondsSince(this.disconnectedAt)) + \" s, stale threshold = \" + this.constructor.staleThreshold + \" s\");\n\t            this.reconnectAttempts++;\n\t            if (this.disconnectedRecently()) {\n\t              return ActionCable.log(\"ConnectionMonitor skipping reopening recent disconnect\");\n\t            } else {\n\t              ActionCable.log(\"ConnectionMonitor reopening\");\n\t              return this.connection.reopen();\n\t            }\n\t          }\n\t        };\n\t\n\t        ConnectionMonitor.prototype.connectionIsStale = function() {\n\t          var ref;\n\t          return secondsSince((ref = this.pingedAt) != null ? ref : this.startedAt) > this.constructor.staleThreshold;\n\t        };\n\t\n\t        ConnectionMonitor.prototype.disconnectedRecently = function() {\n\t          return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;\n\t        };\n\t\n\t        ConnectionMonitor.prototype.visibilityDidChange = function() {\n\t          if (document.visibilityState === \"visible\") {\n\t            return setTimeout((function(_this) {\n\t              return function() {\n\t                if (_this.connectionIsStale() || !_this.connection.isOpen()) {\n\t                  ActionCable.log(\"ConnectionMonitor reopening stale connection on visibilitychange. visbilityState = \" + document.visibilityState);\n\t                  return _this.connection.reopen();\n\t                }\n\t              };\n\t            })(this), 200);\n\t          }\n\t        };\n\t\n\t        now = function() {\n\t          return new Date().getTime();\n\t        };\n\t\n\t        secondsSince = function(time) {\n\t          return (now() - time) / 1000;\n\t        };\n\t\n\t        clamp = function(number, min, max) {\n\t          return Math.max(min, Math.min(max, number));\n\t        };\n\t\n\t        return ConnectionMonitor;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t    (function() {\n\t      var i, message_types, protocols, ref, supportedProtocols, unsupportedProtocol,\n\t        slice = [].slice,\n\t        bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n\t        indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\t\n\t      ref = ActionCable.INTERNAL, message_types = ref.message_types, protocols = ref.protocols;\n\t\n\t      supportedProtocols = 2 <= protocols.length ? slice.call(protocols, 0, i = protocols.length - 1) : (i = 0, []), unsupportedProtocol = protocols[i++];\n\t\n\t      ActionCable.Connection = (function() {\n\t        Connection.reopenDelay = 500;\n\t\n\t        function Connection(consumer) {\n\t          this.consumer = consumer;\n\t          this.open = bind(this.open, this);\n\t          this.subscriptions = this.consumer.subscriptions;\n\t          this.monitor = new ActionCable.ConnectionMonitor(this);\n\t          this.disconnected = true;\n\t        }\n\t\n\t        Connection.prototype.send = function(data) {\n\t          if (this.isOpen()) {\n\t            this.webSocket.send(JSON.stringify(data));\n\t            return true;\n\t          } else {\n\t            return false;\n\t          }\n\t        };\n\t\n\t        Connection.prototype.open = function() {\n\t          if (this.isActive()) {\n\t            ActionCable.log(\"Attempted to open WebSocket, but existing socket is \" + (this.getState()));\n\t            return false;\n\t          } else {\n\t            ActionCable.log(\"Opening WebSocket, current state is \" + (this.getState()) + \", subprotocols: \" + protocols);\n\t            if (this.webSocket != null) {\n\t              this.uninstallEventHandlers();\n\t            }\n\t            this.webSocket = new ActionCable.WebSocket(this.consumer.url, protocols);\n\t            this.installEventHandlers();\n\t            this.monitor.start();\n\t            return true;\n\t          }\n\t        };\n\t\n\t        Connection.prototype.close = function(arg) {\n\t          var allowReconnect, ref1;\n\t          allowReconnect = (arg != null ? arg : {\n\t            allowReconnect: true\n\t          }).allowReconnect;\n\t          if (!allowReconnect) {\n\t            this.monitor.stop();\n\t          }\n\t          if (this.isActive()) {\n\t            return (ref1 = this.webSocket) != null ? ref1.close() : void 0;\n\t          }\n\t        };\n\t\n\t        Connection.prototype.reopen = function() {\n\t          var error;\n\t          ActionCable.log(\"Reopening WebSocket, current state is \" + (this.getState()));\n\t          if (this.isActive()) {\n\t            try {\n\t              return this.close();\n\t            } catch (error1) {\n\t              error = error1;\n\t              return ActionCable.log(\"Failed to reopen WebSocket\", error);\n\t            } finally {\n\t              ActionCable.log(\"Reopening WebSocket in \" + this.constructor.reopenDelay + \"ms\");\n\t              setTimeout(this.open, this.constructor.reopenDelay);\n\t            }\n\t          } else {\n\t            return this.open();\n\t          }\n\t        };\n\t\n\t        Connection.prototype.getProtocol = function() {\n\t          var ref1;\n\t          return (ref1 = this.webSocket) != null ? ref1.protocol : void 0;\n\t        };\n\t\n\t        Connection.prototype.isOpen = function() {\n\t          return this.isState(\"open\");\n\t        };\n\t\n\t        Connection.prototype.isActive = function() {\n\t          return this.isState(\"open\", \"connecting\");\n\t        };\n\t\n\t        Connection.prototype.isProtocolSupported = function() {\n\t          var ref1;\n\t          return ref1 = this.getProtocol(), indexOf.call(supportedProtocols, ref1) >= 0;\n\t        };\n\t\n\t        Connection.prototype.isState = function() {\n\t          var ref1, states;\n\t          states = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n\t          return ref1 = this.getState(), indexOf.call(states, ref1) >= 0;\n\t        };\n\t\n\t        Connection.prototype.getState = function() {\n\t          var ref1, state, value;\n\t          for (state in WebSocket) {\n\t            value = WebSocket[state];\n\t            if (value === ((ref1 = this.webSocket) != null ? ref1.readyState : void 0)) {\n\t              return state.toLowerCase();\n\t            }\n\t          }\n\t          return null;\n\t        };\n\t\n\t        Connection.prototype.installEventHandlers = function() {\n\t          var eventName, handler;\n\t          for (eventName in this.events) {\n\t            handler = this.events[eventName].bind(this);\n\t            this.webSocket[\"on\" + eventName] = handler;\n\t          }\n\t        };\n\t\n\t        Connection.prototype.uninstallEventHandlers = function() {\n\t          var eventName;\n\t          for (eventName in this.events) {\n\t            this.webSocket[\"on\" + eventName] = function() {};\n\t          }\n\t        };\n\t\n\t        Connection.prototype.events = {\n\t          message: function(event) {\n\t            var identifier, message, ref1, type;\n\t            if (!this.isProtocolSupported()) {\n\t              return;\n\t            }\n\t            ref1 = JSON.parse(event.data), identifier = ref1.identifier, message = ref1.message, type = ref1.type;\n\t            switch (type) {\n\t              case message_types.welcome:\n\t                this.monitor.recordConnect();\n\t                return this.subscriptions.reload();\n\t              case message_types.ping:\n\t                return this.monitor.recordPing();\n\t              case message_types.confirmation:\n\t                return this.subscriptions.notify(identifier, \"connected\");\n\t              case message_types.rejection:\n\t                return this.subscriptions.reject(identifier);\n\t              default:\n\t                return this.subscriptions.notify(identifier, \"received\", message);\n\t            }\n\t          },\n\t          open: function() {\n\t            ActionCable.log(\"WebSocket onopen event, using '\" + (this.getProtocol()) + \"' subprotocol\");\n\t            this.disconnected = false;\n\t            if (!this.isProtocolSupported()) {\n\t              ActionCable.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n\t              return this.close({\n\t                allowReconnect: false\n\t              });\n\t            }\n\t          },\n\t          close: function(event) {\n\t            ActionCable.log(\"WebSocket onclose event\");\n\t            if (this.disconnected) {\n\t              return;\n\t            }\n\t            this.disconnected = true;\n\t            this.monitor.recordDisconnect();\n\t            return this.subscriptions.notifyAll(\"disconnected\", {\n\t              willAttemptReconnect: this.monitor.isRunning()\n\t            });\n\t          },\n\t          error: function() {\n\t            return ActionCable.log(\"WebSocket onerror event\");\n\t          }\n\t        };\n\t\n\t        return Connection;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t    (function() {\n\t      var slice = [].slice;\n\t\n\t      ActionCable.Subscriptions = (function() {\n\t        function Subscriptions(consumer) {\n\t          this.consumer = consumer;\n\t          this.subscriptions = [];\n\t        }\n\t\n\t        Subscriptions.prototype.create = function(channelName, mixin) {\n\t          var channel, params, subscription;\n\t          channel = channelName;\n\t          params = typeof channel === \"object\" ? channel : {\n\t            channel: channel\n\t          };\n\t          subscription = new ActionCable.Subscription(this.consumer, params, mixin);\n\t          return this.add(subscription);\n\t        };\n\t\n\t        Subscriptions.prototype.add = function(subscription) {\n\t          this.subscriptions.push(subscription);\n\t          this.consumer.ensureActiveConnection();\n\t          this.notify(subscription, \"initialized\");\n\t          this.sendCommand(subscription, \"subscribe\");\n\t          return subscription;\n\t        };\n\t\n\t        Subscriptions.prototype.remove = function(subscription) {\n\t          this.forget(subscription);\n\t          if (!this.findAll(subscription.identifier).length) {\n\t            this.sendCommand(subscription, \"unsubscribe\");\n\t          }\n\t          return subscription;\n\t        };\n\t\n\t        Subscriptions.prototype.reject = function(identifier) {\n\t          var i, len, ref, results, subscription;\n\t          ref = this.findAll(identifier);\n\t          results = [];\n\t          for (i = 0, len = ref.length; i < len; i++) {\n\t            subscription = ref[i];\n\t            this.forget(subscription);\n\t            this.notify(subscription, \"rejected\");\n\t            results.push(subscription);\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.forget = function(subscription) {\n\t          var s;\n\t          this.subscriptions = (function() {\n\t            var i, len, ref, results;\n\t            ref = this.subscriptions;\n\t            results = [];\n\t            for (i = 0, len = ref.length; i < len; i++) {\n\t              s = ref[i];\n\t              if (s !== subscription) {\n\t                results.push(s);\n\t              }\n\t            }\n\t            return results;\n\t          }).call(this);\n\t          return subscription;\n\t        };\n\t\n\t        Subscriptions.prototype.findAll = function(identifier) {\n\t          var i, len, ref, results, s;\n\t          ref = this.subscriptions;\n\t          results = [];\n\t          for (i = 0, len = ref.length; i < len; i++) {\n\t            s = ref[i];\n\t            if (s.identifier === identifier) {\n\t              results.push(s);\n\t            }\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.reload = function() {\n\t          var i, len, ref, results, subscription;\n\t          ref = this.subscriptions;\n\t          results = [];\n\t          for (i = 0, len = ref.length; i < len; i++) {\n\t            subscription = ref[i];\n\t            results.push(this.sendCommand(subscription, \"subscribe\"));\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.notifyAll = function() {\n\t          var args, callbackName, i, len, ref, results, subscription;\n\t          callbackName = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n\t          ref = this.subscriptions;\n\t          results = [];\n\t          for (i = 0, len = ref.length; i < len; i++) {\n\t            subscription = ref[i];\n\t            results.push(this.notify.apply(this, [subscription, callbackName].concat(slice.call(args))));\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.notify = function() {\n\t          var args, callbackName, i, len, results, subscription, subscriptions;\n\t          subscription = arguments[0], callbackName = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];\n\t          if (typeof subscription === \"string\") {\n\t            subscriptions = this.findAll(subscription);\n\t          } else {\n\t            subscriptions = [subscription];\n\t          }\n\t          results = [];\n\t          for (i = 0, len = subscriptions.length; i < len; i++) {\n\t            subscription = subscriptions[i];\n\t            results.push(typeof subscription[callbackName] === \"function\" ? subscription[callbackName].apply(subscription, args) : void 0);\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.sendCommand = function(subscription, command) {\n\t          var identifier;\n\t          identifier = subscription.identifier;\n\t          return this.consumer.send({\n\t            command: command,\n\t            identifier: identifier\n\t          });\n\t        };\n\t\n\t        return Subscriptions;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t    (function() {\n\t      ActionCable.Subscription = (function() {\n\t        var extend;\n\t\n\t        function Subscription(consumer, params, mixin) {\n\t          this.consumer = consumer;\n\t          if (params == null) {\n\t            params = {};\n\t          }\n\t          this.identifier = JSON.stringify(params);\n\t          extend(this, mixin);\n\t        }\n\t\n\t        Subscription.prototype.perform = function(action, data) {\n\t          if (data == null) {\n\t            data = {};\n\t          }\n\t          data.action = action;\n\t          return this.send(data);\n\t        };\n\t\n\t        Subscription.prototype.send = function(data) {\n\t          return this.consumer.send({\n\t            command: \"message\",\n\t            identifier: this.identifier,\n\t            data: JSON.stringify(data)\n\t          });\n\t        };\n\t\n\t        Subscription.prototype.unsubscribe = function() {\n\t          return this.consumer.subscriptions.remove(this);\n\t        };\n\t\n\t        extend = function(object, properties) {\n\t          var key, value;\n\t          if (properties != null) {\n\t            for (key in properties) {\n\t              value = properties[key];\n\t              object[key] = value;\n\t            }\n\t          }\n\t          return object;\n\t        };\n\t\n\t        return Subscription;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t    (function() {\n\t      ActionCable.Consumer = (function() {\n\t        function Consumer(url) {\n\t          this.url = url;\n\t          this.subscriptions = new ActionCable.Subscriptions(this);\n\t          this.connection = new ActionCable.Connection(this);\n\t        }\n\t\n\t        Consumer.prototype.send = function(data) {\n\t          return this.connection.send(data);\n\t        };\n\t\n\t        Consumer.prototype.connect = function() {\n\t          return this.connection.open();\n\t        };\n\t\n\t        Consumer.prototype.disconnect = function() {\n\t          return this.connection.close({\n\t            allowReconnect: false\n\t          });\n\t        };\n\t\n\t        Consumer.prototype.ensureActiveConnection = function() {\n\t          if (!this.connection.isActive()) {\n\t            return this.connection.open();\n\t          }\n\t        };\n\t\n\t        return Consumer;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t  }).call(this);\n\t\n\t  if (typeof module === \"object\" && module.exports) {\n\t    module.exports = ActionCable;\n\t  } else if (true) {\n\t    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (ActionCable), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  }\n\t}).call(this);\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// redux-cablecar.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c98335cd613e9cc04b85","import middleware from './src/middleware';\n\nexport default middleware;\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","import CableCar from './cableCar';\nimport CableCarDispatcher from './cableCarDispatcher';\n\nlet cableProvider;\n\nconst dispatcher = new CableCarDispatcher();\n\nconst middleware = store => next => (incomingAction) => {\n  const action = incomingAction;\n  let car;\n\n  switch (action.type) {\n\n    case 'CABLECAR_INITIALIZED':\n    case 'CABLECAR_CONNECTED':\n    case 'CABLECAR_DISCONNECTED':\n      return next(action);\n\n    case 'CABLECAR_DESTROY':\n      dispatcher.destroyCar(action.CableCarChannel);\n      return store.getState();\n\n    case 'CABLECAR_DESTROY_ALL':\n      dispatcher.reset();\n      return store.getState();\n\n    case 'CABLECAR_CHANGE_CHANNEL':\n      dispatcher.changeCar(action.previousChannel, action.newChannel, action.options);\n      return store.getState();\n\n    default:\n      car = action.channel ? dispatcher.getCar(action.channel) : dispatcher.getDefaultCar();\n      if (car && car.allows(action) && !action.CableCar__Action) {\n        if (car.running) {\n          car.send(action);\n        } else {\n          console.error('CableCar: Dropped action!',\n            'Attempting to dispatch an action but cable car is not running.',\n            action,\n            'optimisticOnFail: ' + car.options.optimisticOnFail\n          );\n          return car.options.optimisticOnFail ? next(action) : store.getState();\n        }\n        return action.optimistic ? next(action) : store.getState();\n      } else {\n        return next(action);\n      }\n  }\n};\n\nmiddleware.connect = (store, channel, options) => {\n  if (!cableProvider) {\n    try {\n      cableProvider = require('actioncable');\n    } catch(e) {\n      throw new Error(`CableCar: No actionCableProvider set and 'actioncable' Node package failed to load: ${e}`);\n    }\n  }\n\n  let car = new CableCar(cableProvider, store, channel, options);\n  dispatcher.addCar(channel, car);\n\n  // public car object returned\n  return {\n    changeChannel: car.changeChannel.bind(car),\n    getChannel: car.getChannel.bind(car),\n    getParams: car.getParams.bind(car),\n    perform: car.perform.bind(car),\n    send: car.send.bind(car),\n    unsubscribe: car.unsubscribe.bind(car)\n  };\n}\n\nmiddleware.setProvider = (newProvider) => {\n  cableProvider = newProvider;\n}\n\nexport default middleware;\n\n\n\n// WEBPACK FOOTER //\n// ./src/middleware.js","\nexport default class CableCar {\n\n  constructor(cableProvider, store, channel, options = {}) {\n    if (typeof cableProvider === 'undefined') {\n      throw new Error(`CableCar: unknown ActionCable provider: ${cableProvider}`);\n    }\n\n    if (typeof store === 'undefined' || typeof store.dispatch === 'undefined') {\n      throw new Error(`CableCar: unknown store: ${store}`);\n    }\n\n    if (typeof channel !== 'string') {\n      throw new Error(`CableCar: unknown channel: ${channel}`);\n    }\n\n    this.actionCableProvider = cableProvider;\n    this.store = store;\n\n    const defaultOptions = { prefix: 'RAILS', optimisticOnFail: false };\n    this.initialize(channel, Object.assign(defaultOptions, options));\n  }\n\n  initialize(channel, options) {\n\n    this.channel = channel;\n    this.options = options;\n    this.running = false;\n\n    let cableParams = options.params || {};\n    cableParams = Object.assign({ channel }, cableParams);\n\n    this.subscription = this.actionCableProvider.createConsumer(options.wsURL).subscriptions.create(\n      cableParams, {\n        initialized: this.initialized,\n        connected: this.connected,\n        disconnected: this.disconnected,\n        received: this.received,\n        rejected: this.rejected,\n      },\n    );\n  }\n\n  // ActionCable callback functions\n  initialized = () => this.dispatch({ type: 'CABLECAR_INITIALIZED' });\n\n  connected = () => {\n    this.dispatch({ type: 'CABLECAR_CONNECTED' });\n    this.running = true;\n    if (this.options.connected) { this.options.connected.call(); }\n  }\n\n  disconnected = () => {\n    this.dispatch({ type: 'CABLECAR_DISCONNECTED' });\n    this.running = false;\n    if (this.options.disconnected) { this.options.disconnected.call(); }\n  }\n\n  received = (msg) => {\n    this.dispatch(msg);\n  }\n\n  rejected = () => {\n    throw new Error(\n      `CableCar: Attempt to connect was rejected.\n      (Channel: ${this.channel})`,\n    );\n  }\n\n  // Redux dispatch function\n  dispatch(action) {\n    const newAction = Object.assign(action, {\n      channel: this.channel,\n      CableCar__Action: true,\n    });\n    this.store.dispatch(newAction);\n  }\n\n  allows(action) {\n    if (typeof action !== 'object' || typeof action.type !== 'string') {\n      throw new Error(`CableCar: ${action} is not a valid redux action ({ type: ... })`);\n    }\n\n    return this.matchPrefix(action.type);\n  }\n\n  matchPrefix(type) {\n    const prefix = type.slice(0, this.options.prefix.length);\n    return prefix === this.options.prefix;\n  }\n\n  // ActionCable subscription functions (exposed globally)\n  changeChannel(channel, options = {}) {\n    this.unsubscribe();\n    this.initialize(channel, Object.assign(this.options, options));\n  }\n\n  getChannel() {\n    return this.channel;\n  }\n\n  getParams() {\n    return this.options.params;\n  }\n\n  perform(method, payload) {\n    this.subscription.perform(method, payload);\n  }\n\n  send(action) {\n    this.subscription.send(action);\n  }\n\n  unsubscribe() {\n    this.subscription.unsubscribe();\n    this.disconnected();\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/cableCar.js","\nexport default class CableCarDispatcher {\n\n  constructor(provider) {\n    let lines = {};\n\n    this.addLine = (line, car) => { lines[line] = car; }\n    this.clearAllLines = () => { lines = {}; }\n    this.clearLine = (line) => { lines[line] = undefined; }\n    this.getLines = () => lines;\n  }\n\n  addCar(line, car) {\n    if (this.getCar(line)) {\n      throw(new ReferenceError(\n        'CableCar Dispatcher: cannot connect two cars to same line/channel: ' + line\n      ));\n    }\n    this.addLine(line, car);\n    return car;\n  }\n\n  changeCar(oldLine, newLine, options) {\n    let car = this.getCar(oldLine);\n\n    if (!car) {\n      console.error(new ReferenceError(\n        'CableCar Dispatcher (change failed): no car found on line/channel: ' + oldLine\n      ));\n      return false;\n    }\n\n    if (car.changeChannel) {\n      car.changeChannel(newLine, options);\n      this.clearLine(oldLine);\n      this.addLine(newLine, car);\n      return car;\n    } else {\n      console.error(new ReferenceError(\n        'CableCar Dispatcher (change failed): car has no changeChannel function'\n      ), car);\n      return false;\n    }\n  }\n\n  destroyCar(line) {\n    let activeLine = line || this.getSingleActiveLine();\n\n    if (!activeLine) {\n      console.error(new ReferenceError(\n        'CableCar Dispatcher (destroy failed): No car found on line/channel: ' + line\n      ))\n      return false;\n    }\n\n    let car = this.getCar(activeLine);\n    if (car && car.unsubscribe) {\n      car.unsubscribe();\n      this.clearLine(activeLine);\n      return car;\n    } else {\n      console.error(new ReferenceError(\n        'CableCar Dispatcher (destroy failed): car has no unsubscribe function'\n      ), car);\n      return false;\n    }\n  }\n\n  getCar(line) {\n    return this.getLines()[line];\n  }\n\n  getDefaultCar() {\n    let activeLine = this.getSingleActiveLine();\n    return activeLine ? this.getLines()[activeLine] : undefined;\n  }\n\n  getSingleActiveLine() {\n    const allLines = this.getLines();\n    let activeLines = [];\n    for (let line in allLines) {\n      if (allLines[line]) { activeLines.push(line); }\n    }\n    return activeLines.length === 1 ? activeLines[0] : undefined;\n  }\n\n  reset() {\n    this.clearAllLines();\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/cableCarDispatcher.js","(function() {\n  var context = this;\n\n  (function() {\n    (function() {\n      var slice = [].slice;\n\n      this.ActionCable = {\n        INTERNAL: {\n          \"message_types\": {\n            \"welcome\": \"welcome\",\n            \"ping\": \"ping\",\n            \"confirmation\": \"confirm_subscription\",\n            \"rejection\": \"reject_subscription\"\n          },\n          \"default_mount_path\": \"/cable\",\n          \"protocols\": [\"actioncable-v1-json\", \"actioncable-unsupported\"]\n        },\n        WebSocket: window.WebSocket,\n        logger: window.console,\n        createConsumer: function(url) {\n          var ref;\n          if (url == null) {\n            url = (ref = this.getConfig(\"url\")) != null ? ref : this.INTERNAL.default_mount_path;\n          }\n          return new ActionCable.Consumer(this.createWebSocketURL(url));\n        },\n        getConfig: function(name) {\n          var element;\n          element = document.head.querySelector(\"meta[name='action-cable-\" + name + \"']\");\n          return element != null ? element.getAttribute(\"content\") : void 0;\n        },\n        createWebSocketURL: function(url) {\n          var a;\n          if (url && !/^wss?:/i.test(url)) {\n            a = document.createElement(\"a\");\n            a.href = url;\n            a.href = a.href;\n            a.protocol = a.protocol.replace(\"http\", \"ws\");\n            return a.href;\n          } else {\n            return url;\n          }\n        },\n        startDebugging: function() {\n          return this.debugging = true;\n        },\n        stopDebugging: function() {\n          return this.debugging = null;\n        },\n        log: function() {\n          var messages, ref;\n          messages = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          if (this.debugging) {\n            messages.push(Date.now());\n            return (ref = this.logger).log.apply(ref, [\"[ActionCable]\"].concat(slice.call(messages)));\n          }\n        }\n      };\n\n    }).call(this);\n  }).call(context);\n\n  var ActionCable = context.ActionCable;\n\n  (function() {\n    (function() {\n      var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n      ActionCable.ConnectionMonitor = (function() {\n        var clamp, now, secondsSince;\n\n        ConnectionMonitor.pollInterval = {\n          min: 3,\n          max: 30\n        };\n\n        ConnectionMonitor.staleThreshold = 6;\n\n        function ConnectionMonitor(connection) {\n          this.connection = connection;\n          this.visibilityDidChange = bind(this.visibilityDidChange, this);\n          this.reconnectAttempts = 0;\n        }\n\n        ConnectionMonitor.prototype.start = function() {\n          if (!this.isRunning()) {\n            this.startedAt = now();\n            delete this.stoppedAt;\n            this.startPolling();\n            document.addEventListener(\"visibilitychange\", this.visibilityDidChange);\n            return ActionCable.log(\"ConnectionMonitor started. pollInterval = \" + (this.getPollInterval()) + \" ms\");\n          }\n        };\n\n        ConnectionMonitor.prototype.stop = function() {\n          if (this.isRunning()) {\n            this.stoppedAt = now();\n            this.stopPolling();\n            document.removeEventListener(\"visibilitychange\", this.visibilityDidChange);\n            return ActionCable.log(\"ConnectionMonitor stopped\");\n          }\n        };\n\n        ConnectionMonitor.prototype.isRunning = function() {\n          return (this.startedAt != null) && (this.stoppedAt == null);\n        };\n\n        ConnectionMonitor.prototype.recordPing = function() {\n          return this.pingedAt = now();\n        };\n\n        ConnectionMonitor.prototype.recordConnect = function() {\n          this.reconnectAttempts = 0;\n          this.recordPing();\n          delete this.disconnectedAt;\n          return ActionCable.log(\"ConnectionMonitor recorded connect\");\n        };\n\n        ConnectionMonitor.prototype.recordDisconnect = function() {\n          this.disconnectedAt = now();\n          return ActionCable.log(\"ConnectionMonitor recorded disconnect\");\n        };\n\n        ConnectionMonitor.prototype.startPolling = function() {\n          this.stopPolling();\n          return this.poll();\n        };\n\n        ConnectionMonitor.prototype.stopPolling = function() {\n          return clearTimeout(this.pollTimeout);\n        };\n\n        ConnectionMonitor.prototype.poll = function() {\n          return this.pollTimeout = setTimeout((function(_this) {\n            return function() {\n              _this.reconnectIfStale();\n              return _this.poll();\n            };\n          })(this), this.getPollInterval());\n        };\n\n        ConnectionMonitor.prototype.getPollInterval = function() {\n          var interval, max, min, ref;\n          ref = this.constructor.pollInterval, min = ref.min, max = ref.max;\n          interval = 5 * Math.log(this.reconnectAttempts + 1);\n          return Math.round(clamp(interval, min, max) * 1000);\n        };\n\n        ConnectionMonitor.prototype.reconnectIfStale = function() {\n          if (this.connectionIsStale()) {\n            ActionCable.log(\"ConnectionMonitor detected stale connection. reconnectAttempts = \" + this.reconnectAttempts + \", pollInterval = \" + (this.getPollInterval()) + \" ms, time disconnected = \" + (secondsSince(this.disconnectedAt)) + \" s, stale threshold = \" + this.constructor.staleThreshold + \" s\");\n            this.reconnectAttempts++;\n            if (this.disconnectedRecently()) {\n              return ActionCable.log(\"ConnectionMonitor skipping reopening recent disconnect\");\n            } else {\n              ActionCable.log(\"ConnectionMonitor reopening\");\n              return this.connection.reopen();\n            }\n          }\n        };\n\n        ConnectionMonitor.prototype.connectionIsStale = function() {\n          var ref;\n          return secondsSince((ref = this.pingedAt) != null ? ref : this.startedAt) > this.constructor.staleThreshold;\n        };\n\n        ConnectionMonitor.prototype.disconnectedRecently = function() {\n          return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;\n        };\n\n        ConnectionMonitor.prototype.visibilityDidChange = function() {\n          if (document.visibilityState === \"visible\") {\n            return setTimeout((function(_this) {\n              return function() {\n                if (_this.connectionIsStale() || !_this.connection.isOpen()) {\n                  ActionCable.log(\"ConnectionMonitor reopening stale connection on visibilitychange. visbilityState = \" + document.visibilityState);\n                  return _this.connection.reopen();\n                }\n              };\n            })(this), 200);\n          }\n        };\n\n        now = function() {\n          return new Date().getTime();\n        };\n\n        secondsSince = function(time) {\n          return (now() - time) / 1000;\n        };\n\n        clamp = function(number, min, max) {\n          return Math.max(min, Math.min(max, number));\n        };\n\n        return ConnectionMonitor;\n\n      })();\n\n    }).call(this);\n    (function() {\n      var i, message_types, protocols, ref, supportedProtocols, unsupportedProtocol,\n        slice = [].slice,\n        bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n        indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n      ref = ActionCable.INTERNAL, message_types = ref.message_types, protocols = ref.protocols;\n\n      supportedProtocols = 2 <= protocols.length ? slice.call(protocols, 0, i = protocols.length - 1) : (i = 0, []), unsupportedProtocol = protocols[i++];\n\n      ActionCable.Connection = (function() {\n        Connection.reopenDelay = 500;\n\n        function Connection(consumer) {\n          this.consumer = consumer;\n          this.open = bind(this.open, this);\n          this.subscriptions = this.consumer.subscriptions;\n          this.monitor = new ActionCable.ConnectionMonitor(this);\n          this.disconnected = true;\n        }\n\n        Connection.prototype.send = function(data) {\n          if (this.isOpen()) {\n            this.webSocket.send(JSON.stringify(data));\n            return true;\n          } else {\n            return false;\n          }\n        };\n\n        Connection.prototype.open = function() {\n          if (this.isActive()) {\n            ActionCable.log(\"Attempted to open WebSocket, but existing socket is \" + (this.getState()));\n            return false;\n          } else {\n            ActionCable.log(\"Opening WebSocket, current state is \" + (this.getState()) + \", subprotocols: \" + protocols);\n            if (this.webSocket != null) {\n              this.uninstallEventHandlers();\n            }\n            this.webSocket = new ActionCable.WebSocket(this.consumer.url, protocols);\n            this.installEventHandlers();\n            this.monitor.start();\n            return true;\n          }\n        };\n\n        Connection.prototype.close = function(arg) {\n          var allowReconnect, ref1;\n          allowReconnect = (arg != null ? arg : {\n            allowReconnect: true\n          }).allowReconnect;\n          if (!allowReconnect) {\n            this.monitor.stop();\n          }\n          if (this.isActive()) {\n            return (ref1 = this.webSocket) != null ? ref1.close() : void 0;\n          }\n        };\n\n        Connection.prototype.reopen = function() {\n          var error;\n          ActionCable.log(\"Reopening WebSocket, current state is \" + (this.getState()));\n          if (this.isActive()) {\n            try {\n              return this.close();\n            } catch (error1) {\n              error = error1;\n              return ActionCable.log(\"Failed to reopen WebSocket\", error);\n            } finally {\n              ActionCable.log(\"Reopening WebSocket in \" + this.constructor.reopenDelay + \"ms\");\n              setTimeout(this.open, this.constructor.reopenDelay);\n            }\n          } else {\n            return this.open();\n          }\n        };\n\n        Connection.prototype.getProtocol = function() {\n          var ref1;\n          return (ref1 = this.webSocket) != null ? ref1.protocol : void 0;\n        };\n\n        Connection.prototype.isOpen = function() {\n          return this.isState(\"open\");\n        };\n\n        Connection.prototype.isActive = function() {\n          return this.isState(\"open\", \"connecting\");\n        };\n\n        Connection.prototype.isProtocolSupported = function() {\n          var ref1;\n          return ref1 = this.getProtocol(), indexOf.call(supportedProtocols, ref1) >= 0;\n        };\n\n        Connection.prototype.isState = function() {\n          var ref1, states;\n          states = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          return ref1 = this.getState(), indexOf.call(states, ref1) >= 0;\n        };\n\n        Connection.prototype.getState = function() {\n          var ref1, state, value;\n          for (state in WebSocket) {\n            value = WebSocket[state];\n            if (value === ((ref1 = this.webSocket) != null ? ref1.readyState : void 0)) {\n              return state.toLowerCase();\n            }\n          }\n          return null;\n        };\n\n        Connection.prototype.installEventHandlers = function() {\n          var eventName, handler;\n          for (eventName in this.events) {\n            handler = this.events[eventName].bind(this);\n            this.webSocket[\"on\" + eventName] = handler;\n          }\n        };\n\n        Connection.prototype.uninstallEventHandlers = function() {\n          var eventName;\n          for (eventName in this.events) {\n            this.webSocket[\"on\" + eventName] = function() {};\n          }\n        };\n\n        Connection.prototype.events = {\n          message: function(event) {\n            var identifier, message, ref1, type;\n            if (!this.isProtocolSupported()) {\n              return;\n            }\n            ref1 = JSON.parse(event.data), identifier = ref1.identifier, message = ref1.message, type = ref1.type;\n            switch (type) {\n              case message_types.welcome:\n                this.monitor.recordConnect();\n                return this.subscriptions.reload();\n              case message_types.ping:\n                return this.monitor.recordPing();\n              case message_types.confirmation:\n                return this.subscriptions.notify(identifier, \"connected\");\n              case message_types.rejection:\n                return this.subscriptions.reject(identifier);\n              default:\n                return this.subscriptions.notify(identifier, \"received\", message);\n            }\n          },\n          open: function() {\n            ActionCable.log(\"WebSocket onopen event, using '\" + (this.getProtocol()) + \"' subprotocol\");\n            this.disconnected = false;\n            if (!this.isProtocolSupported()) {\n              ActionCable.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n              return this.close({\n                allowReconnect: false\n              });\n            }\n          },\n          close: function(event) {\n            ActionCable.log(\"WebSocket onclose event\");\n            if (this.disconnected) {\n              return;\n            }\n            this.disconnected = true;\n            this.monitor.recordDisconnect();\n            return this.subscriptions.notifyAll(\"disconnected\", {\n              willAttemptReconnect: this.monitor.isRunning()\n            });\n          },\n          error: function() {\n            return ActionCable.log(\"WebSocket onerror event\");\n          }\n        };\n\n        return Connection;\n\n      })();\n\n    }).call(this);\n    (function() {\n      var slice = [].slice;\n\n      ActionCable.Subscriptions = (function() {\n        function Subscriptions(consumer) {\n          this.consumer = consumer;\n          this.subscriptions = [];\n        }\n\n        Subscriptions.prototype.create = function(channelName, mixin) {\n          var channel, params, subscription;\n          channel = channelName;\n          params = typeof channel === \"object\" ? channel : {\n            channel: channel\n          };\n          subscription = new ActionCable.Subscription(this.consumer, params, mixin);\n          return this.add(subscription);\n        };\n\n        Subscriptions.prototype.add = function(subscription) {\n          this.subscriptions.push(subscription);\n          this.consumer.ensureActiveConnection();\n          this.notify(subscription, \"initialized\");\n          this.sendCommand(subscription, \"subscribe\");\n          return subscription;\n        };\n\n        Subscriptions.prototype.remove = function(subscription) {\n          this.forget(subscription);\n          if (!this.findAll(subscription.identifier).length) {\n            this.sendCommand(subscription, \"unsubscribe\");\n          }\n          return subscription;\n        };\n\n        Subscriptions.prototype.reject = function(identifier) {\n          var i, len, ref, results, subscription;\n          ref = this.findAll(identifier);\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            subscription = ref[i];\n            this.forget(subscription);\n            this.notify(subscription, \"rejected\");\n            results.push(subscription);\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.forget = function(subscription) {\n          var s;\n          this.subscriptions = (function() {\n            var i, len, ref, results;\n            ref = this.subscriptions;\n            results = [];\n            for (i = 0, len = ref.length; i < len; i++) {\n              s = ref[i];\n              if (s !== subscription) {\n                results.push(s);\n              }\n            }\n            return results;\n          }).call(this);\n          return subscription;\n        };\n\n        Subscriptions.prototype.findAll = function(identifier) {\n          var i, len, ref, results, s;\n          ref = this.subscriptions;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            s = ref[i];\n            if (s.identifier === identifier) {\n              results.push(s);\n            }\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.reload = function() {\n          var i, len, ref, results, subscription;\n          ref = this.subscriptions;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            subscription = ref[i];\n            results.push(this.sendCommand(subscription, \"subscribe\"));\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.notifyAll = function() {\n          var args, callbackName, i, len, ref, results, subscription;\n          callbackName = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n          ref = this.subscriptions;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            subscription = ref[i];\n            results.push(this.notify.apply(this, [subscription, callbackName].concat(slice.call(args))));\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.notify = function() {\n          var args, callbackName, i, len, results, subscription, subscriptions;\n          subscription = arguments[0], callbackName = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];\n          if (typeof subscription === \"string\") {\n            subscriptions = this.findAll(subscription);\n          } else {\n            subscriptions = [subscription];\n          }\n          results = [];\n          for (i = 0, len = subscriptions.length; i < len; i++) {\n            subscription = subscriptions[i];\n            results.push(typeof subscription[callbackName] === \"function\" ? subscription[callbackName].apply(subscription, args) : void 0);\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.sendCommand = function(subscription, command) {\n          var identifier;\n          identifier = subscription.identifier;\n          return this.consumer.send({\n            command: command,\n            identifier: identifier\n          });\n        };\n\n        return Subscriptions;\n\n      })();\n\n    }).call(this);\n    (function() {\n      ActionCable.Subscription = (function() {\n        var extend;\n\n        function Subscription(consumer, params, mixin) {\n          this.consumer = consumer;\n          if (params == null) {\n            params = {};\n          }\n          this.identifier = JSON.stringify(params);\n          extend(this, mixin);\n        }\n\n        Subscription.prototype.perform = function(action, data) {\n          if (data == null) {\n            data = {};\n          }\n          data.action = action;\n          return this.send(data);\n        };\n\n        Subscription.prototype.send = function(data) {\n          return this.consumer.send({\n            command: \"message\",\n            identifier: this.identifier,\n            data: JSON.stringify(data)\n          });\n        };\n\n        Subscription.prototype.unsubscribe = function() {\n          return this.consumer.subscriptions.remove(this);\n        };\n\n        extend = function(object, properties) {\n          var key, value;\n          if (properties != null) {\n            for (key in properties) {\n              value = properties[key];\n              object[key] = value;\n            }\n          }\n          return object;\n        };\n\n        return Subscription;\n\n      })();\n\n    }).call(this);\n    (function() {\n      ActionCable.Consumer = (function() {\n        function Consumer(url) {\n          this.url = url;\n          this.subscriptions = new ActionCable.Subscriptions(this);\n          this.connection = new ActionCable.Connection(this);\n        }\n\n        Consumer.prototype.send = function(data) {\n          return this.connection.send(data);\n        };\n\n        Consumer.prototype.connect = function() {\n          return this.connection.open();\n        };\n\n        Consumer.prototype.disconnect = function() {\n          return this.connection.close({\n            allowReconnect: false\n          });\n        };\n\n        Consumer.prototype.ensureActiveConnection = function() {\n          if (!this.connection.isActive()) {\n            return this.connection.open();\n          }\n        };\n\n        return Consumer;\n\n      })();\n\n    }).call(this);\n  }).call(this);\n\n  if (typeof module === \"object\" && module.exports) {\n    module.exports = ActionCable;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(ActionCable);\n  }\n}).call(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/actioncable/lib/assets/compiled/action_cable.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}